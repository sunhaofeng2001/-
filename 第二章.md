第二章、信息的表示与处理
=========
#### 写在前面
现代计算机存储和处理的信息以二值信号表示。二值信号能够很容易地被表示、存储和传输。
孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释, 即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。  
无符号编码基于传统的二进制表示法，表示大于或者等于零的数字。  
补码编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。  
浮点数编码是表示实数的科学记数法的以2为基数的版本。  
计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会溢出（overflow)。溢出会导致某些令人吃惊的后果。  
#### 2.1 信息存储
大多数计算机使用 8 位的块，或者字节（byte), 作为最小的可寻址的内存单位，而不是访问内存中单独的位。  
机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为虚拟地址空间。
#### 2.1.1 十六进制表示法  
一个字节由 8 位组成。在 C 语言中，以 Ox 或 0X 开头的数字常量被认为是十六进制的值。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20214922.png)
#### 2.1.2 字数据大小
每台计算机都有一个字长（word size), 指明指针数据的标称大小,为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空
间的最大大小。也就是说，对于一个字长为 w 的机器而言，虚拟地址的范围为 0-2^w，程序最多访问 2^w 字节。  
大多数 64 位机器也可以运行为 32 位机器编译的程序，这是一种向后兼容。因此，举
例来说，当程序 prog.c 用如下伪指令编译后
```Linux
linux> gcc -m32 prog.c
```
该程序就可以在 32 位或 64 位机器上正确运行。另一方面，若程序用下述伪指令编译
```Linux
linux> gcc -m64 prog.c
```
那就只能在 64 位机器上运行。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20220032.png)
#### 2.1.3 寻址和字节顺序
对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及
在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序
列，对象的地址为所使用字节中最小的地址。
假设变量 x 的类型为 int，位于地址 0x100 处，它的十六进制值为 0x01234567。地
址范围 0x100 - 0x103 的字节顺序依赖于机器的类型：
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20222006.png)
我们用 typedef 将数据类型 byte_pointer 定义为一个指向类型为 “unsignedchar”的对象的指针。这样一个字节指针引用一个字节序列，其中每个字节都被认为是一个非负整数。第一个例程 show_bytes 的输入是一个字节序列的地址，它用一个字节指针
以及一个字节数来指示。该字节数指定为数据类型 Size_t 表示数据结构大小的首选数
据类型。show_bytes 打印出每个以十六进制表示的字节。
```C
#include<stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len)
{
    size_t i;
    for(i=0;i<len;i++)
        printf("%.2x,start[i]");
    printf("\n");
}
void show_int(int x)
{
  show_bytes((byte_pointer)&x, sizeof(int));
}
void show_float(int x)
{
  show_bytes((byte_pointer)&x, sizeof(float));
}
void show_pointer(int x)
{
  show_bytes((byte_pointer)&x, sizeof(void*));
}
int main()
{
  int val;
  int ival = val;
  float fval = (float)ival;
  int*pval = &ival;
  show_int(ival);
  show_float(fval);
  show_pointer(pval);
}
```
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20224126.png)
#### 2.1.4 表示字符串
C 语言中字符串被编码为一个以 null(其值为 0)字符结尾的字符数组。每个字符都由
某个标准编码来表示，最常见的是 ASCII 字符码。  
在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文
本数据比二进制数据具有更强的平台独立性。  
不同的机器类型使用不同的且不兼容的指令和编码方
式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进
制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。  
计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器
没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。
#### 2.1.6 布尔代数简介
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20230635.png)
![imahe](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20231127.png)
#### 2.1.7 C语言中的位级运算
| 就是 OR(或），& 就是 AND(与）， 〜 就是 NOT(取反）， 而 ^ 就是 EXCLUSIVE-OR(异或）。 
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20233721.png)  
位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。  
让我们来看一个例子，掩码 0xFF(最低的 8 位为 1)表示一个字的低位
字节。位级运算 x&OxFF 生成一个由 x 的最低有效字节组成的值，而其他的字节就被置为 0 。
#### 2.1.8 C 语言中的逻辑运算
C 语言还提供了一组逻辑运算符 ||，&& 和 ！，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。  
逻辑运算认为所有非零的参数都表示 TRUE 而参数 0 表示 FALSE 它们返回 1 或者 0, 分别表示结果为 TRUE 或者为 FALSE。如果对
第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。
#### 2.1.9 C 语言中的移位运算
C 语言还提供了一组移位运算，向左或者向右移动位模式。
左移位：x 向左移动 6 位，丢弃最高的々位，并在右端补 6 个 0。
右移位：逻辑右移在左端补k个0。算术右移是在左端补k个最高有效位的值。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20235752.png)  
#### 2.2 整数表示
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20194928.png)  
#### 2.2.1 整数数据类型
C 语言支持多种整型数据类型一表示有限范围的整数。  
唯一一个与机器相关的取值范围是大小指示符 long的。大多数 64 位机器使用 8 个字节的表示，比 32 位机器上使用的 4 个字节的表示的取值范围大很多。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20195222.png)  
#### 2.2.2 无符号数的编码
假设有一个整数数据类型有 w 位。我们可以将位向量写成 3, 表示整个向量，或者写成x->  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20200314.png)  
#### 2.2.3 补码编码
最常见的有符号数的计算机表示方式就是补码形式。在这个定义中，将字的最高有效位解释为负权。  
补码的范围是不对称的：|TMin|=|TMax|+1 。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20200823.png)  
#### 2.2.4 有符号数和无符号数之间的转换
```C
short int v = -12345;
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", v, uv);
```
输出为 v = -12345, uv = 53191
强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。
#### 2.2.5 C语言中的有符号数与无符号数
C 语言支持所有整型数据类型的有符号和无符号运算。尽管
C 语言标准没有指定有符号数要采用某种表示，但是几乎所有的机器都使用补码。通常，
大多数数字都默认为是有符号的。例如，当声明一个像 12345 或者 0X1A2B 这样的常量时，
这个值就被认为是有符号的。要创建一个无符号常量，必须加上后缀字符 ‘U’ 或者 ‘u’，
例如，12345U 或者 0xlA2Bu。
显式的强制类型转换就会导致转换发生，就像下面的代码：
```C
int tx, ty;
unsigned ux, uy;
tx = (int)
uy = (unsigned) ty;
```
另外，当一种类型的表达式被赋值给另外一种类型的变量时，转换是隐式发生的，就像下面的代码：
```C
int tx, ty;
unsigned ux, uy;
tx = ux; /* Cast to signed */
uy = ty; /* Cast to unsigned */
```
#### 2.2.6 拓展一个数字的位表示
一个常见的运算是在不同字长的整数之间转换，同时又保持数值不变。当然，当目标
数据类型太小以至于不能表示想要的值时，这根本就是不可能的。然而，从一个较小的数
据类型转换到一个较大的类型，应该总是可能的。  
要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加 0。
这种运算被称为零扩展（zero extension)。  
考虑下面的代码:
```C
short sx = -12345;
unsigned short usx = sx;
int x = sx;
unsigned ux = usx;
printf( = %d:\t", sx);
show.bytes((byte_pointer) &sx, sizeof(short));
printf("usx = %u:\t", usx);
showÿbytes((byte_pointer) &usx, sizeof(unsigned short));
printf("x = %d:\t",x);
show_bytes((byte_pointer) &x, sizeof(int));
printf("ux = %u:\t", ux);
show_bytes((byte_pointer) &ux, sizeof(unsigned));
```
在采用补码表示的 32 位大端法机器上运行这段代码时，打印出如下输出：
```
sx  = -12345: cf c7
usx = 53191:  cf c7
x   = -12345: ff ff cf c7
ux  = 53191:  00 00 cf c7
```
尽管 -12345 的补码表示和 53191 的无符号表示在 16 位字长时是相同的，但是
在 32 位字长时却是不同的。特别地，-12345 的十六进制表示为 0XFFFFCFC7, 而 53191 的十
六进制表示为0x0000CFC7。前者使用的是符号扩展棗 最开头加了 16 位，都是最高有效位 1,
表示为十六进制就是0xFFFF。后者开头使用 16 个0来扩展，表示为十六进制就是 0x0000。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20204522.png)
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20204540.png)
#### 2.2.7 截断数字
假设我们不用额外的位来扩展一个数值，而是减少表示一个数字的位数。例如下面代码中这种情况：
```
int x = 53191;
short sx = (short) x; /* -12345 */
int y = sx; /* -12345 */
```
当我们把 x 强制类型转换为 short 时，我们就将 32 位的 int 截断为了16 位的 short int 。  
就像前面所看到的，这个 16 位的位模式就是一12 345 的补码表示。当我们把它强制类型转换回 int 时，符号扩展把高 16 位设置为 1, 从而生成-12345 的 
32 位补码表示。  
#### 2.2.8 关于有符号数与无符号数的建议
有符号数到无符号数的隐式强制类型转换导致了某些非直观的
行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差
别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，
我们经常忽视了它的影响。
#### 2.3 整数运算
两个正数相加会得出一个负数，而比较表达式x<y和比较表达式 x-y<0 会产生不同的结果。这些属性是由于计算机运算的有限性造成的。
#### 2.3.1 无符号加法
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20211903.png) 
#### 2.3.2 补码加法
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20212453.png)
#### 2.3.3 补码的非
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20212747.png)
#### 2.3.4 无符号乘法
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20212846.png)
#### 2.3.5 补码乘法
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20212901.png)
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20212913.png)
#### 2.3.6 乘以常数
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20213822.png)
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20213835.png)
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20213851.png)
由于整数乘法比移位和加法的代价要大得多，许多 C 语言编译器试图以移位、加法和
减法的组合来消除很多整数乘以常数的情况。例如，假设一个程序包含表达式 x* 14。利
用14=2^3+2^2+2^1， 编译器会将乘法重写为（x<<3)+(x<<2) +(x<<1)将一个乘法替换为三
个移位和两个加法。无论 x 是无符号的还是补码，甚至当乘法会导致溢出时，两个计算都
会得到一样的结果。（根据整数运算的属性可以证明这一点。）更好的是，编译器还可以利
用属性14=2^4-2^1 将乘法重写为（x<<4)-(x<<l)，这时只需要两个移位和一个减法。
### 2.3.7 除以2的幂
整数除法要比整数乘法更慢棗 需要 30 个或者更多的时钟周期。除以 2 的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移。无符号和补
码数分别使用逻辑移位和算术移位来达到目的。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20215113.png)
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20215133.png)
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20215152.png)
#### 2.3.8 关于整数运算的最后思考
计算机执行的“整数”运算实际上是一种模运算形式。表示数字的
有限字长限制了可能的值的取值范围，结果运算可能溢出。我们还看到，补码表示提供了
一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实
现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补
码形式表示的，都有完全一样或者非常类似的位级行为。
#### 2.4 浮点数
在本节中，我们将看到 IEEE 浮点格式中数字是如何表示的。我们还将探讨舍入
(rounding)的问题，即当一个数字不能被准确地表示为这种格式时，就必须向上调整或者
向下调整。然后，我们将探讨加法、乘法和关系运算符的数学属性。
#### 2.4.1 二进制小数
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/Inked%E6%89%B9%E6%B3%A8%202020-08-07%20221315_LI.jpg)
#### 2.4.2 IEEE浮点表示
IEEE 浮点标准用 V=(-1)^s * M * 2^E 的形式来表示一个数：
        •符号（sign) s 决定这数是负数(s=l)还是正数(s=0)，而对于数值 0 的符号位解释作为特殊情况处理。  
        •尾数(significand) M 是一个二进制小数，它的范围是1~2-e或者是0~l-e    
        •阶码（exponent) E的作用是对浮点数加权，这个权重是 2 的 E 幂(可能是负数)。将浮点数的位表示划分为三个字段，分别对这些值进行编码:  
        •一个单独的符号位 s 直接编码符号 s 。   
        •k位的阶码字段 exp=e(k-1)*e(k-2)* ……e(0)编码阶码E  
        •n位小数字段 frac=f(n-1)……f(1)f(0)编码尾数M,但是编码出来的值也依赖于阶码字段的值是否等于 0。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20222553.png)
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20222602.png)
#### 2.4.3 数字示例
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20222614.png)
#### 2.4.4 舍入
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-07%20225216.png)
#### 2.4.5 浮点运算
#### 2.4.6 C语言中的浮点数
所有的 C 语言版本提供了两种不同的浮点数据类型：float 和 double 在支持 IEEE 浮点
格式的机器上，这些数据类型就对应于单精度和双精度浮点。另外，这类机器使用向偶数舍人
的舍入方式。
#### 2.5 小结
计算机将信息编码为位（比特）， 通常组织成字节序列。有不同的编码方式用来表示整数、实数和字
符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。
C 语言的设计可以包容多种不同字长和数字编码的实现。  
在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数 C 语言实现遵循的原则是底层
的位模式不变。  
由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示
范围时，有限长度能够引起数值溢出。当浮点数非常接近于 0.0, 从而转换成零时，也会下溢。
必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算术属
性，比如结合性。
