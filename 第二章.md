第二章、信息的表示与处理
=========
#### 写在前面
现代计算机存储和处理的信息以二值信号表示。二值信号能够很容易地被表示、存储和传输。
孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释, 即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。  
无符号编码基于传统的二进制表示法，表示大于或者等于零的数字。  
补码编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。  
浮点数编码是表示实数的科学记数法的以2为基数的版本。  
计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会溢出（overflow)。溢出会导致某些令人吃惊的后果。  
#### 2.1 信息存储
大多数计算机使用 8 位的块，或者字节（byte), 作为最小的可寻址的内存单位，而不是访问内存中单独的位。  
机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为虚拟地址空间。
#### 2.1.1 十六进制表示法  
一个字节由 8 位组成。在 C 语言中，以 Ox 或 0X 开头的数字常量被认为是十六进制的值。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20214922.png)
#### 2.1.2 字数据大小
每台计算机都有一个字长（word size), 指明指针数据的标称大小,为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空
间的最大大小。也就是说，对于一个字长为 w 的机器而言，虚拟地址的范围为 0-2^w，程序最多访问 2^w 字节。  
大多数 64 位机器也可以运行为 32 位机器编译的程序，这是一种向后兼容。因此，举
例来说，当程序 prog.c 用如下伪指令编译后
```Linux
linux> gcc -m32 prog.c
```
该程序就可以在 32 位或 64 位机器上正确运行。另一方面，若程序用下述伪指令编译
```Linux
linux> gcc -m64 prog.c
```
那就只能在 64 位机器上运行。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20220032.png)
#### 2.1.3 寻址和字节顺序
对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及
在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序
列，对象的地址为所使用字节中最小的地址。
假设变量 x 的类型为 int，位于地址 0x100 处，它的十六进制值为 0x01234567。地
址范围 0x100 - 0x103 的字节顺序依赖于机器的类型：
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20222006.png)
我们用 typedef 将数据类型 byte_pointer 定义为一个指向类型为 “unsignedchar”的对象的指针。这样一个字节指针引用一个字节序列，其中每个字节都被认为是一个非负整数。第一个例程 show_bytes 的输入是一个字节序列的地址，它用一个字节指针
以及一个字节数来指示。该字节数指定为数据类型 Size_t 表示数据结构大小的首选数
据类型。show_bytes 打印出每个以十六进制表示的字节。
```C
#include<stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len)
{
    size_t i;
    for(i=0;i<len;i++)
        printf("%.2x,start[i]");
    printf("\n");
}
void show_int(int x)
{
  show_bytes((byte_pointer)&x, sizeof(int));
}
void show_float(int x)
{
  show_bytes((byte_pointer)&x, sizeof(float));
}
void show_pointer(int x)
{
  show_bytes((byte_pointer)&x, sizeof(void*));
}
int main()
{
  int val;
  int ival = val;
  float fval = (float)ival;
  int*pval = &ival;
  show_int(ival);
  show_float(fval);
  show_pointer(pval);
}
```
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20224126.png)
#### 2.1.4 表示字符串
C 语言中字符串被编码为一个以 null(其值为 0)字符结尾的字符数组。每个字符都由
某个标准编码来表示，最常见的是 ASCII 字符码。  
在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文
本数据比二进制数据具有更强的平台独立性。  
不同的机器类型使用不同的且不兼容的指令和编码方
式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进
制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。  
计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器
没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。
#### 2.1.6 布尔代数简介
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20230635.png)
![imahe](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20231127.png)
#### 2.1.7 C语言中的位级运算
| 就是 OR(或），& 就是 AND(与）， 〜 就是 NOT(取反）， 而 ^ 就是 EXCLUSIVE-OR(异或）。 
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20233721.png)
位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。  
让我们来看一个例子，掩码 0xFF(最低的 8 位为 1)表示一个字的低位
字节。位级运算 x&OxFF 生成一个由 x 的最低有效字节组成的值，而其他的字节就被置为 0 。
#### 2.1.8 C 语言中的逻辑运算
C 语言还提供了一组逻辑运算符 ||，&& 和 ！，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。  
逻辑运算认为所有非零的参数都表示 TRUE 而参数 0 表示 FALSE 它们返回 1 或者 0, 分别表示结果为 TRUE 或者为 FALSE。如果对
第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。
#### 2.1.9 C 语言中的移位运算
C 语言还提供了一组移位运算，向左或者向右移动位模式。
左移位：x 向左移动 6 位，丢弃最高的々位，并在右端补 6 个 0。
右移位：逻辑右移在左端补k个0。算术右移是在左端补k个最高有效位的值。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-04%20235752.png)
