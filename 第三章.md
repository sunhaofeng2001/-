第三章、程序的机器级表示
=======
#### 写在前面
计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写
存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集
和操作系统遵循的惯例，经过一系列的阶段生成机器代码。  
以适当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。
#### 3.1 历史观点
Intel 处理器系列俗称 x86, 经历了一个长期的、不断进化的发展过程。  
每个后继处理器的设计都是后向兼容的棗 较早版本上编译的代码可以在较新的处理器上运行。 
#### 3.2 程序编码
一个 C 程序，有两个文件 pi.C 和 P2.C 。我们用 Unix 命令行编译这些代码：
```
linux> gcc -Og -o p p1.c 
```
命令 gcc 指的就是 GCCC 编译器。编译选项-Oge告诉编译器使用会生成符合原始 C 代码整体结构的机
器代码的优化等级。  
首先，C 预处理器扩展源代码，插人所有用#include 命令指定的文件，并扩展所有#define声明指定
的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 pl.s 和 p2.s 接下来，汇
编器会将汇编代码转化成二进制目标代码文件 pl.o 和 p2.o 目标代码是机器代码的一种
形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两
个目标代码文件与实现库函数（例如 printf)的代码合并，并产生最终的可执行代码文件 P
(由命令行指示符-op指定的）。   
#### 3.2.1 机器级代码
第一种是由指令集体 系结构或指令集架构（Instruction Set Architecture, ISA)来定义机器级程序的
格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数
ISA 包括 x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束
后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可
以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。第二种抽象是，机器级程
序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系
统的实际实现是将多个硬件存储器和操作系统软件组合起来，


	• 程序计数器（通常称为 "PC" 在 x86-64 中用％rip 表示）给出将要执行的下一条指令在内存中的地址。  
	• 整数寄存器文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或整数数据。
	  有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
	• 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 和 while 语句。  
	• 一组向量寄存器可以存放一个或多个整数或浮点数值。
虽然 C 语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。  
一条机器指令只执行一个非常基本的操作。
#### 3.2.2 代码示例
们写了一个 C 语言代码文件 mstore.c 包含如下的函数定义:
```
long mult2(long,long);

void multstore(long x,long y,long *dest)
{
	long t = mult2(x,y);
	*dest = t;
}
```
在命令行上使用 “-S” 选项，就能看到 C 语言编译器产生的汇编代码:
```
linux> gcc -Og -S mstore.c
```
汇编代码文件包含各种声明，包括下面几行:
```
multstore:
	pushq %rbx
	movq %rdx, %rbx
	call mult2
	movq %rax, (%rbx)
	popq %rbx
	ret
```
上面代码中每个缩进去的行都对应于一条机器指令。
如果我们使用 “-c” 命令行选项，GCC 会编译并汇编该代码：
```
linux> gcc -Og -c mstore.c
```
这就会产生目标代码文件 mstore.o, 它是二进制格式的。  
即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

要查看机器代码文件的内容，有一类称为反汇编器（disassembler)的程序非常有用。
在 Linux 系统中，带'd'命令行标志的程序 OBJDUMP(表示 “object dump”) 可以充当这个角色：
```
linux> objdump -d mstore.o
```
结果如下:
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20192302.png)
其中一些关于机器代码和它的反汇编表示的特性值得注意：

	
	• x86-64 的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
	• 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 pushq%rbx 是以字节值 53 开头的。
	• 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
	• 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的'q'。
	 这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 call 和 ret 指令添加了‘q’ 后缀，同样，省略这些后缀也没有问题。
