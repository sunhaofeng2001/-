第三章、程序的机器级表示
=======
#### 写在前面
计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写
存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集
和操作系统遵循的惯例，经过一系列的阶段生成机器代码。  
以适当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。
#### 3.1 历史观点
Intel 处理器系列俗称 x86, 经历了一个长期的、不断进化的发展过程。  
每个后继处理器的设计都是后向兼容的棗 较早版本上编译的代码可以在较新的处理器上运行。 
#### 3.2 程序编码
一个 C 程序，有两个文件 pi.C 和 P2.C 。我们用 Unix 命令行编译这些代码：
```
linux> gcc -Og -o p p1.c 
```
命令 gcc 指的就是 GCCC 编译器。编译选项-Oge告诉编译器使用会生成符合原始 C 代码整体结构的机
器代码的优化等级。  
首先，C 预处理器扩展源代码，插人所有用#include 命令指定的文件，并扩展所有#define声明指定
的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 pl.s 和 p2.s 接下来，汇
编器会将汇编代码转化成二进制目标代码文件 pl.o 和 p2.o 目标代码是机器代码的一种
形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两
个目标代码文件与实现库函数（例如 printf)的代码合并，并产生最终的可执行代码文件 P
(由命令行指示符-op指定的）。   
#### 3.2.1 机器级代码
第一种是由指令集体 系结构或指令集架构（Instruction Set Architecture, ISA)来定义机器级程序的
格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数
ISA 包括 x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束
后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可
以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。第二种抽象是，机器级程
序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系
统的实际实现是将多个硬件存储器和操作系统软件组合起来，


	• 程序计数器（通常称为 "PC" 在 x86-64 中用％rip 表示）给出将要执行的下一条指令在内存中的地址。  
	• 整数寄存器文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或整数数据。
	  有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
	• 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 和 while 语句。  
	• 一组向量寄存器可以存放一个或多个整数或浮点数值。
虽然 C 语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。  
一条机器指令只执行一个非常基本的操作。
#### 3.2.2 代码示例
们写了一个 C 语言代码文件 mstore.c 包含如下的函数定义:
```C
long mult2(long,long);

void multstore(long x,long y,long *dest)
{
	long t = mult2(x,y);
	*dest = t;
}
```
在命令行上使用 “-S” 选项，就能看到 C 语言编译器产生的汇编代码:
```
linux> gcc -Og -S mstore.c
```
汇编代码文件包含各种声明，包括下面几行:
```
multstore:
	pushq %rbx
	movq %rdx, %rbx
	call mult2
	movq %rax, (%rbx)
	popq %rbx
	ret
```
上面代码中每个缩进去的行都对应于一条机器指令。
如果我们使用 “-c” 命令行选项，GCC 会编译并汇编该代码：
```
linux> gcc -Og -c mstore.c
```
这就会产生目标代码文件 mstore.o, 它是二进制格式的。  
即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

要查看机器代码文件的内容，有一类称为反汇编器（disassembler)的程序非常有用。
在 Linux 系统中，带'd'命令行标志的程序 OBJDUMP(表示 “object dump”) 可以充当这个角色：
```
linux> objdump -d mstore.o
```
结果如下:  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20192302.png)  
其中一些关于机器代码和它的反汇编表示的特性值得注意：

	
	• x86-64 的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
	• 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 pushq%rbx 是以字节值 53 开头的。
	• 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
	• 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的'q'。
	 这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 call 和 ret 指令添加了‘q’ 后缀，同样，省略这些后缀也没有问题。
#### 3.2.3 关于格式的注解
所有以 . 开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些
行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。
#### 3.3 数据格式
由于是从 16 位体系结构扩展成 32 位的，Intel 用术语“字（word)”表示 16 位数据类
型。因此，称 32 位数为 “双字（double words)。称 64 位数为 “四字”（quad words)。  
大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大
小。例如，数据传送指令有四个变种：movb(传送字节）、 movw(传送字）、 movl(传送双
字)和 movq(传送四字）。 后缀‘1’用来表示双字，因为 32 位数被看成是“长字（long
word)。
#### 3.4 访问信息
一个 X86-64 的中央处理单元（CPU)包含一组 16 个存储 64 位值的通用目的寄存器。
这些寄存器用来存储整数数据和指针。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20225222.png)  
指令可以对这 16 个寄存器的低位字节中存放的不同
大小的数据进行操作。字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字
节，32 位操作可以访问最低的 4 个字节，而 64 位操作可以访问整个寄存器。
#### 3.4.1 操作数指示符
大多数指令有一个或多个操作数（operand)，指示出执行一个操作中要使用的源数据
值，以及放置结果的目的位置。
第一种类型是立即数（immediate), 用来表示常数值。在 ATT 格式的汇编代码中，立即数的书写方式是‘$’后面跟一个用标准 C 表
示法表示的整数，比如，$-577 或$0xlF不同的指令允许的立即数值范围不同，汇编器
会自动选择最紧凑的方式进行数值编码。第二种类型是寄存器（register)，它表示某个寄
存器的内容，16 个寄存器的低位 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数，
这些字节数分别对应于 8 位、16 位、32 位或 64 位。我们用符号r表示任
意寄存器 a, 用引用 R[r]来表示它的值，这是将寄存器集合看成一个数组 R ,用寄存器标
识符作为索引。第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内
存位置。因为将内存看成一个很大的字节数组，我们用符号M[Addr]表示对存储在内存
中从地址 Addr 开始的 b 个字节值的引用。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20225222.png)  
#### 3.4.2 数据传输指令
最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用
性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功
能。  
最简单形式的数据传送指令棗 MOV 类。这些指令把数据从源位置
复制到目的位置，不做任何变化。MOV 类由四条指令组成：movb movw movl
movq。这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同：分别是 1、
2、4 和 8 字节。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20230456.png)   
源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个
位置，要么是一个寄存器或者，要么是一个内存地址。X86-64 加了一条限制，传送指令的
两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两
条指令。 第一条指令将源值加载到寄存器中，第二条将该寄存器值写人目的位置。

两类数据移动指令，在将较小的源值复制到较大的目的时使
用。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。MOVZ 类中的
指令把目的中剩余的字节填充为 0, 而 MOVS类中的指令通过符号扩展来填充，把源操作
的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个
字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三
条指令，包括了所有的源大小为 1 个和 2 个字节、目的大小为 2 个和 4 个的情况，当然只
考虑目的大于源的情况。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20230951.png)  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20231001.png)  
#### 3.4.3 数据传输示例
```C
long exchange(long *xp, long y)
{
	long x = *xp;
	*xp = y;
	return x;
}
```
```
exchange:
	movq    (%rdi) , %rax
	movq    %rsi   ,(%rdi)
	ret
```
函数 exchange 由三条指令实现：两个数据传送（movq), 加上一条
返回函数被调用点的指令（ret)。过程参数 xp 和 y 分别存储在寄存器 中。然后，指
令 2 从内存中读出 x, 把它存放到寄存器％rax 中，直接实现了 C 程序中的操作 x =* xp稍
后，用寄存器％rax 从这个函数返回一个值，因而返回值就是 x。 指令 3 将 y 写入到寄存
器 %rdi 中的 xp 指向的内存位置，直接实现了操作 * xp = y。  
我们看到 C 语言中所谓的“指针”其实就
是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存
器。其次，像 x 这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访
问内存要快得多。
#### 3.4.4 压入和弹出栈数据
找是一种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则。通过 push 操作把数据压入栈中，通过 pop 操作删除数据。
栈可以实现为一个数组，总是从数组的一端插人和删除元素。这一端被称为栈
顶 。在 X86-64 中，程序栈存放在内存中某个区域。栈向下增长，这样一
来，栈顶元素的地址是所有栈中元素地址中最低的。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20232035.png)  
pushq 指令的功能是把数据压人到栈上，而 popq 指令是弹出数据。这些指令都只有
一个操作数 -- 压入的数据源和弹出的数据目的。
将一个四字值压人栈中，首先要将栈指针减 8, 然后将值写到新的栈顶地址。因此，
指令 pushq * rbp 的行为等价于下面两条指令：
```
  subq $8,%rsp
  movq %rbp,(%rsp)
```
弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加 8。因此，指令 popq
%raX 等价于下面两条指令：
```
movq (%rsp),%rax
addq $8,%rsp
```
#### 3.5 算数与逻辑运算
指令类ADD 由四条加法指令组成：addb addw addl 和 addq分别是字节加法、字加法、双字加法和四字加法。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20233506.png)  
#### 3.5.1 加载有效地址
加栽有效地址（load effective address)指令 leaq 实际上是 movq 指令的变形。它的指
令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。
为了说明 leaq在编译出的代码中的使用，看看下面这个 C 程序：
```C
long scale(long x, long y, long z)
{
	long t=x+4*y+12*z;
	return t;
}
```
编译时，该函数的算术运算以三条 leaq 指令实现，就像右边注释说明的那样:
```
scale:
  leaq (%rdi,%rsi,4), %rax
  leaq (%rdx,%rdx,2), %rdx
  leaq (%rax,%rdx,4), %rax
  ret
```
#### 3.5.2 一元和二元操作
第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是
—个寄存器，也可以是一个内存位置。  
第三组是二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起 C 语言
中的赋值运算符，例如 x-=y 。不过，要注意，源操作数是第一个，目的操作数是第二个。
#### 3.5.3 移位操作
最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算
术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器％cl 中。（这些指令很
特别，因为只允许以这个特定的寄存器作为操作数。）
#### 3.5.4 讨论
大多数指令，既可以用于无符号运算，也可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运
算的一种比较好的方法的原因之一。
#### 3.5.5 特殊的算术操作
两个 64 位有符号或无符号整数相乘得到的乘积需要 128
位来表示。x86-64 指令集对 128 位（16 字节）数的操作提供有限的支持。延续字（2 字节〉、
双字(4 字节)和四字(8 字节）的命名惯例，Intel 把 16 字节的数称为八字 (oct word)。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20234924.png)  
```C
#include <inttypes.h>
typedef unsigned __intl28 uintl28_t;
void store_uprod(uintl28_t *dest, uint64_t x, uint64_t y) 
{
    *dest = x * (uintl28_t) y;
}
```
我们显式地把 x 和 y 声明为 64 位的数字，使用文件 inttypes.h 中
声明的定义，这是对标准 C 扩展的一部分。不幸的是，这个标准没有提供 128 位的值。所
以我们只好依赖 GCC 提供的 128 位整数支持，用名字__1此128 来声明。
```
store_uprod:
  movq  %rsi, %rax
  mulq  %rdx
  movq  %rax, (%rdi)
  movq  %rdx, 8(%rdi)
  ret
```
出除法或取模操作这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。有符号除法指令 idivl 将寄存器%rdx(高 64 位）
和%rax(低 64 位）中的 128 位数作为被除数，而除数作为指令的操作数给出。指令将商存
储在寄存器％rax 中，将余数存储在寄存器%rdx中。  
用下面这个 C 函数来说明 X86T64 如何实现除法，它计算了两个 64 位有符号数的商和余数:
```C
void remdiv(long x, long y, long *qp, long *rp) 
{
   long q = x/y;
   long r = x%y;
   *qp = q;
   *rp = r;
}
```
```
remdiv:
  movq  %rdx, %r8
  movq  %rdi, %rax
  cqto   
  idivq 
  movq  %rsi, (%r8)
  movq  %rax, (%rcx)
  ret
```
