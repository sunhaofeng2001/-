第三章、程序的机器级表示
=======
#### 写在前面
计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写
存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集
和操作系统遵循的惯例，经过一系列的阶段生成机器代码。  
以适当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。
#### 3.1 历史观点
Intel 处理器系列俗称 x86, 经历了一个长期的、不断进化的发展过程。  
每个后继处理器的设计都是后向兼容的。 较早版本上编译的代码可以在较新的处理器上运行。 
#### 3.2 程序编码
一个 C 程序，有两个文件 pi.C 和 P2.C 。我们用 Unix 命令行编译这些代码：
```
linux> gcc -Og -o p p1.c 
```
命令 gcc 指的就是 GCCC 编译器。编译选项-Oge告诉编译器使用会生成符合原始 C 代码整体结构的机
器代码的优化等级。  
首先，C 预处理器扩展源代码，插人所有用#include 命令指定的文件，并扩展所有#define声明指定
的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 pl.s 和 p2.s 接下来，汇
编器会将汇编代码转化成二进制目标代码文件 pl.o 和 p2.o 目标代码是机器代码的一种
形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两
个目标代码文件与实现库函数（例如 printf)的代码合并，并产生最终的可执行代码文件 P
(由命令行指示符-op指定的）。   
#### 3.2.1 机器级代码
第一种是由指令集体 系结构或指令集架构（Instruction Set Architecture, ISA)来定义机器级程序的
格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数
ISA 包括 x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束
后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可
以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。第二种抽象是，机器级程
序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系
统的实际实现是将多个硬件存储器和操作系统软件组合起来，


	• 程序计数器（通常称为 "PC" 在 x86-64 中用％rip 表示）给出将要执行的下一条指令在内存中的地址。  
	• 整数寄存器文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或整数数据。
	  有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
	• 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 和 while 语句。  
	• 一组向量寄存器可以存放一个或多个整数或浮点数值。
虽然 C 语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。  
一条机器指令只执行一个非常基本的操作。
#### 3.2.2 代码示例
们写了一个 C 语言代码文件 mstore.c 包含如下的函数定义:
```C
long mult2(long,long);

void multstore(long x,long y,long *dest)
{
	long t = mult2(x,y);
	*dest = t;
}
```
在命令行上使用 “-S” 选项，就能看到 C 语言编译器产生的汇编代码:
```
linux> gcc -Og -S mstore.c
```
汇编代码文件包含各种声明，包括下面几行:
```
multstore:
	pushq %rbx
	movq %rdx, %rbx
	call mult2
	movq %rax, (%rbx)
	popq %rbx
	ret
```
上面代码中每个缩进去的行都对应于一条机器指令。
如果我们使用 “-c” 命令行选项，GCC 会编译并汇编该代码：
```
linux> gcc -Og -c mstore.c
```
这就会产生目标代码文件 mstore.o, 它是二进制格式的。  
即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

要查看机器代码文件的内容，有一类称为反汇编器（disassembler)的程序非常有用。
在 Linux 系统中，带'd'命令行标志的程序 OBJDUMP(表示 “object dump”) 可以充当这个角色：
```
linux> objdump -d mstore.o
```
结果如下:  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20192302.png)  
其中一些关于机器代码和它的反汇编表示的特性值得注意：

	
	• x86-64 的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
	• 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 pushq%rbx 是以字节值 53 开头的。
	• 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
	• 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的'q'。
	 这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 call 和 ret 指令添加了‘q’ 后缀，同样，省略这些后缀也没有问题。
#### 3.2.3 关于格式的注解
所有以 . 开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些
行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。
#### 3.3 数据格式
由于是从 16 位体系结构扩展成 32 位的，Intel 用术语“字（word)”表示 16 位数据类
型。因此，称 32 位数为 “双字（double words)。称 64 位数为 “四字”（quad words)。  
大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大
小。例如，数据传送指令有四个变种：movb(传送字节）、 movw(传送字）、 movl(传送双
字)和 movq(传送四字）。 后缀‘1’用来表示双字，因为 32 位数被看成是“长字（long
word)。
#### 3.4 访问信息
一个 X86-64 的中央处理单元（CPU)包含一组 16 个存储 64 位值的通用目的寄存器。
这些寄存器用来存储整数数据和指针。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20225222.png)  
指令可以对这 16 个寄存器的低位字节中存放的不同
大小的数据进行操作。字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字
节，32 位操作可以访问最低的 4 个字节，而 64 位操作可以访问整个寄存器。
#### 3.4.1 操作数指示符
大多数指令有一个或多个操作数（operand)，指示出执行一个操作中要使用的源数据
值，以及放置结果的目的位置。
第一种类型是立即数（immediate), 用来表示常数值。在 ATT 格式的汇编代码中，立即数的书写方式是‘$’后面跟一个用标准 C 表
示法表示的整数，比如，$-577 或$0xlF不同的指令允许的立即数值范围不同，汇编器
会自动选择最紧凑的方式进行数值编码。第二种类型是寄存器（register)，它表示某个寄
存器的内容，16 个寄存器的低位 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数，
这些字节数分别对应于 8 位、16 位、32 位或 64 位。我们用符号r表示任
意寄存器 a, 用引用 R[r]来表示它的值，这是将寄存器集合看成一个数组 R ,用寄存器标
识符作为索引。第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内
存位置。因为将内存看成一个很大的字节数组，我们用符号M[Addr]表示对存储在内存
中从地址 Addr 开始的 b 个字节值的引用。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20225222.png)  
#### 3.4.2 数据传输指令
最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用
性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功
能。  
最简单形式的数据传送指令棗 MOV 类。这些指令把数据从源位置
复制到目的位置，不做任何变化。MOV 类由四条指令组成：movb movw movl
movq。这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同：分别是 1、
2、4 和 8 字节。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20230456.png)   
源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个
位置，要么是一个寄存器或者，要么是一个内存地址。X86-64 加了一条限制，传送指令的
两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两
条指令。 第一条指令将源值加载到寄存器中，第二条将该寄存器值写人目的位置。

两类数据移动指令，在将较小的源值复制到较大的目的时使
用。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。MOVZ 类中的
指令把目的中剩余的字节填充为 0, 而 MOVS类中的指令通过符号扩展来填充，把源操作
的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个
字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三
条指令，包括了所有的源大小为 1 个和 2 个字节、目的大小为 2 个和 4 个的情况，当然只
考虑目的大于源的情况。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20230951.png)  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20231001.png)  
#### 3.4.3 数据传输示例
```C
long exchange(long *xp, long y)
{
	long x = *xp;
	*xp = y;
	return x;
}
```
```
exchange:
	movq    (%rdi) , %rax
	movq    %rsi   ,(%rdi)
	ret
```
函数 exchange 由三条指令实现：两个数据传送（movq), 加上一条
返回函数被调用点的指令（ret)。过程参数 xp 和 y 分别存储在寄存器 中。然后，指
令 2 从内存中读出 x, 把它存放到寄存器％rax 中，直接实现了 C 程序中的操作 x =* xp稍
后，用寄存器％rax 从这个函数返回一个值，因而返回值就是 x。 指令 3 将 y 写入到寄存
器 %rdi 中的 xp 指向的内存位置，直接实现了操作 * xp = y。  
我们看到 C 语言中所谓的“指针”其实就
是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存
器。其次，像 x 这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访
问内存要快得多。
#### 3.4.4 压入和弹出栈数据
找是一种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则。通过 push 操作把数据压入栈中，通过 pop 操作删除数据。
栈可以实现为一个数组，总是从数组的一端插人和删除元素。这一端被称为栈
顶 。在 X86-64 中，程序栈存放在内存中某个区域。栈向下增长，这样一
来，栈顶元素的地址是所有栈中元素地址中最低的。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20232035.png)  
pushq 指令的功能是把数据压人到栈上，而 popq 指令是弹出数据。这些指令都只有
一个操作数 -- 压入的数据源和弹出的数据目的。
将一个四字值压人栈中，首先要将栈指针减 8, 然后将值写到新的栈顶地址。因此，
指令 pushq * rbp 的行为等价于下面两条指令：
```
  subq $8,%rsp
  movq %rbp,(%rsp)
```
弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加 8。因此，指令 popq
%raX 等价于下面两条指令：
```
movq (%rsp),%rax
addq $8,%rsp
```
#### 3.5 算数与逻辑运算
指令类ADD 由四条加法指令组成：addb addw addl 和 addq分别是字节加法、字加法、双字加法和四字加法。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20233506.png)  
#### 3.5.1 加载有效地址
加栽有效地址（load effective address)指令 leaq 实际上是 movq 指令的变形。它的指
令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。
为了说明 leaq在编译出的代码中的使用，看看下面这个 C 程序：
```C
long scale(long x, long y, long z)
{
	long t=x+4*y+12*z;
	return t;
}
```
编译时，该函数的算术运算以三条 leaq 指令实现，就像右边注释说明的那样:
```
scale:
  leaq (%rdi,%rsi,4), %rax
  leaq (%rdx,%rdx,2), %rdx
  leaq (%rax,%rdx,4), %rax
  ret
```
#### 3.5.2 一元和二元操作
第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是
—个寄存器，也可以是一个内存位置。  
第三组是二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起 C 语言
中的赋值运算符，例如 x-=y 。不过，要注意，源操作数是第一个，目的操作数是第二个。
#### 3.5.3 移位操作
最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算
术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器％cl 中。（这些指令很
特别，因为只允许以这个特定的寄存器作为操作数。）
#### 3.5.4 讨论
大多数指令，既可以用于无符号运算，也可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运
算的一种比较好的方法的原因之一。
#### 3.5.5 特殊的算术操作
两个 64 位有符号或无符号整数相乘得到的乘积需要 128
位来表示。x86-64 指令集对 128 位（16 字节）数的操作提供有限的支持。延续字（2 字节〉、
双字(4 字节)和四字(8 字节）的命名惯例，Intel 把 16 字节的数称为八字 (oct word)。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-09%20234924.png)  
```C
#include <inttypes.h>
typedef unsigned __intl28 uintl28_t;
void store_uprod(uintl28_t *dest, uint64_t x, uint64_t y) 
{
    *dest = x * (uintl28_t) y;
}
```
我们显式地把 x 和 y 声明为 64 位的数字，使用文件 inttypes.h 中
声明的定义，这是对标准 C 扩展的一部分。不幸的是，这个标准没有提供 128 位的值。所
以我们只好依赖 GCC 提供的 128 位整数支持，用名字__1此128 来声明。
```
store_uprod:
  movq  %rsi, %rax
  mulq  %rdx
  movq  %rax, (%rdi)
  movq  %rdx, 8(%rdi)
  ret
```
出除法或取模操作这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。有符号除法指令 idivl 将寄存器%rdx(高 64 位）
和%rax(低 64 位）中的 128 位数作为被除数，而除数作为指令的操作数给出。指令将商存
储在寄存器％rax 中，将余数存储在寄存器%rdx中。  
用下面这个 C 函数来说明 X86T64 如何实现除法，它计算了两个 64 位有符号数的商和余数:
```C
void remdiv(long x, long y, long *qp, long *rp) 
{
   long q = x/y;
   long r = x%y;
   *qp = q;
   *rp = r;
}
```
```
remdiv:
  movq  %rdx, %r8
  movq  %rdi, %rax
  cqto   
  idivq 
  movq  %rsi, (%r8)
  movq  %rax, (%rcx)
  ret
```
#### 3.6 控制
机器代码提供两种基本的低级机制来实现有条件的
行为；测试数据值，然后根据测试的结果来改变控制流或者数据流。
用 jump 指令可以改变一组机器代码指令的执行顺序，jump 指令指定控制应该被
传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种
低级机制基础之上的指令序列，来实现 C 语言的控制结构。
#### 3.6.1 条件码
除了整数寄存器，CPU 还维护着一组单个位的条件码（condition code)寄存器，它们
描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。
CF: 进位标志。最近的操作使最高位产生了进位。可用来检査无符号操作的溢出。
ZF: 零标志。最近的操作得出的结果为 0。
SF: 符号标志。最近的操作得到的结果为负数。
OF: 溢出标志。最近的操作导致一个补码溢出棗 正溢出或负溢出。
```C
CF   (unsigned) t < (unsigned) a    //无符号溢出
ZF   (t == 0)                       //零
SF   (t < 0)                        //负数
OF   (a<0==b<0)&&(t<0!=a<0)         //有符号溢出
```
CMP 指
令根据两个操作数之差来设置条件码。
除了只设置条件码而不更新目的寄存器
之外，CMP 指令与 SUB 指令的行为是
一样的。  
TEST 指
令的行为与 AND 指令一样，除了它们只
设置条件码而不改变目的寄存器的值。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-10%20110607.png)  
#### 3.6.2 访问条件码
条件码通常不会直接读取，常用的使用方法有三种：  
1)可以根据条件码的某种组合，将一个字节设置为 0 或者 1  
2)可以条件跳转到程序的某个其他的部分  
3)可以有条件地传送数据  
对于第一种情况，指令根据条件码的某种组合，将一个字节
设置为 0 或者 1。我们将这一整类指令称为 SET 指令；它们之间的区别就在于它们考虑的
条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-10%20111109.png)  
#### 3.6.3 跳转指令
跳转(jump)指令会导
致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。
```
 movq  $0,%rax
 jmp   .L1
 movq  (%rax),%rdx
.L1:
 popq  %rdx
```
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-10%20112936.png)  
#### 3.6.4 转跳指令的编码
在汇编代码中，跳转目标
用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有
几种不同的编码，但是最常用都是 PC 相对的（PC-relative)。
它们会将目标指令
的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编
码为 1、2 或 4 个字节。第二种编码方法是给出“绝对”地址，用 4 个字节直接指定目标。
汇编器和链接器会选择适当的跳转目的编码。
#### 3.6.5 用条件控制来实现条件分支
将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。
```C
long lt_cnt = 0;
long ge_cnt = 0;

long absdiff_se(long x,long y)
{
	long result;
	if(x<y)
	{
		lt_cnt++;
		result = y-x;
	}
	else
	{
		ge_cnt++;
		result = x-y;
	}
	return result;
}
```
```
absdiff_se:
  cmpq    %rsi, %rdi           Compare x:y
  jge     .L2                  If >= goto x_ge_y
  addq    $1, lt_cnt(%rip)     It_cnt++
  movq    %rsi, %rax           
  subq    %rdi, %rax           result = y-x
  ret                          return
 .L2:                          x_ge_y
  addq    $1, ge_cnt(%rip)     ge_cnt++
  movq    %rdi, %rax
  subq    %rsi, %rax           result = x-y
  ret                          Return
```
#### 3.6.6 用条件传送来实现条件分支
实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条
执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代
处理器上，它可能会非常低效。  
一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然
后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但
是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理
器的性能特性。
```C
long absdiff(long x,long y)
{
	long result;
	if(x < y)
		result = y-x;
	else
		result = x-y;
	return result;
}
```
```
absdiff:
  movq    %rsi, %rax   
  subq    %rdi, %rax     rval = y-x
  movq    %rdi, %rdx
  subq    %rsi, %rdx     aval = x-y
  cmpq    %rsi, %rdi     Compare x:y
  cmovge  %rdx, %rax     If >=, rval = eval
  ret                    Return rval
```
处理器通过使用流水线来获得高性能，在流水线中，一
条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取
指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数
器）。 这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执
行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这
样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（也称为“分支”）时，只
有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻
辑来猜测每条跳转指令是否会执行。
#### 3.6.7 循环
汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。GCC 和其他汇编器产生的循环
代码主要基于两种基本的循环模式。
```C
long fact_do(long n)
{
	long result = 1;
	do{
		result *= n;
		n = n -1;
	}while(n > 1)
	return result;
}
```
```
fact_do:
   movl    $1, %eax       Set result = 1
 .L2:                   loop:
   imulq   %rdi, %rax      Compute  result *= n
   subq    $1, %rdi        Decrement n
   cmpq    $1, %rdi        Compare  n:1
   jg      .L2             If >, goto loop
   rep; ret                Return
```
```C
long fact_while(long n)
{
	long result = 1;
	while(n>1)
	{
		result *= n;
		n = n-1;
	}
	return result;
}
```
```
fact_while:
  movl  $1, %eax     Set result = 1
  jmp   .L5          Goto test
 .L6:               loop:
  imulp %rdi, %rax   Compute result *= n
  subq  $1, %rdi     Decrement n
 .L5                test:
  cmpq  $1, %rdi     Compare n:1
  jp    .L6          If >. goto loop
  rep;ret            Return 
```
#### 3.6.8 switch 语句
```C
void switch_eg(long x, long n, long*dest)
{
	long val = x;
	switch (n){
	case 100:
		val *= 13;
		break;
	case 102:
		val += 10;
	case 103:
		val += 11;
		break;
	case 104:
	case 106:
		val *= val;
		break;
	default: 
		val = 0;
	}
	*dest = val;
}
```
```
switch_eg:
   subq   $100, %rsi             Compute index - n-100
   cmpq   $6, %rsi               Compare index:6
   ja     .L8                    If >, goto loc_def
   jmp    *.L4(,%rsi,8)          Goto *jt[index]
  .L3:                          loc_A:
   leap   (%rdi,%rdi,2), %rax    3*x
   leap   (%rdi,%rax,4), %rdi    val = 13*x
   jmp    .L2                    Goto done
  .L5:                          loc_B:
   addq   $10, %rdi              x = x + 10
  .L6:                          loc_C:
   addq   $11, %rdi              val = x + 11
   jmp    .L2                    Goto done
  .L7:                          loc_D:
   imulq  %rdi, %rdi             val = x * x
   jmp    .L2                    Goto done
  .L8:                          loc_def:
   movl   $0, %edi               val = 0
  .L2:                          done:
   movq   %rdi,(%rdx)            *dest = val
   ret                           Return
```
执行 switch 语句的关键步骤是通过跳转表来访问代码位置。
jmp 指令的操作数有前缀' * '表明这是一个间接跳转，操作数指定一个内存位置，索引由寄存器%rsi 给出，这个寄存
器保存着 index 的值。
#### 3.7 过程
过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可
选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。
过程P 调用过程 Q 。 Q 执行后返回到 P。 这些动作包括下面一个或多个机制：

     传递控制。在进人过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为
    P 中调用 Q 后面那条指令的 地址。
     传递数据。P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。
    分配和释放内存。在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须
     释放这些存储空间。
#### 3.7.1 运行时栈
。在过程 P 调用过程 Q
的例子中，可以看到当 Q 在执行时，P 以及所有
在向上追溯到 P 的调用链中的过程，都是暂时被
挂起的。当 Q 运行时，它只需要为局部变量分配
新的存储空间，或者设置到另一个过程的调用。
另一方面，当 Q返回时，任何它所分配的局部存
储空间都可以被释放。因此，程序可以用栈来管
理它的过程所需要的存储空间，找和程序寄存器
存放着传递控制和数据、分配内存所需要的信息。
当 P调用 Q时，控制和数据信息添加到栈尾。当 P
返回时，这些信息会释放掉。  
当 X86-64 过程需要的存储空间超出寄存器
能够存放的大小时，就会在栈上分配空间。这
个部分称为过程的栈帧（stack fram)。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-10%20232923.png)  
当前正在执行的过程的帧总是在栈
顶。当过程 P 调用过程 Q 时，会把返回地址压人栈中，指明当 Q 返回时，要从 P 程序的哪
个位置继续执行。我们把这个返回地址当做 P 的栈帧的一部分，因为它存放的是与 P 相关
的状态。Q 的代码会扩展当前栈的边界，分配它的找帧所需的空间。在这个空间中，它可
以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数过程的栈帧都
是定长的，在过程的开始就分配好了。但是有些过程需要变长的帧。
通过寄存器，过程 P 可以传递最多 6 个整数值(也就是指针和整数）， 但是如果
Q 需要更多的参数，P 可以在调用 Q 之前在自己的栈帧里存储好这些参数。  
为了提髙空间和时间效率，X86-64 过程只分配自己所需要的栈帧部分。
#### 3.7.2 转移控制
将控制从函数 P 转移到函数 Q 只需要简单地把程序计数器CPC)设置为 Q 的代码的起始位
置。不过，当稍后从 Q 返回的时候，处理器必须记录好它需要继续 P 的执行的代码位置。在
x86-64 机器中，这个信息是用指令 call Q 调用过程 Q 来记录的。.该指令会把地址 A 压入栈
中，并将 PC 设置为 Q 的起始地址。压人的地址 A 被称为返回地址，是紧跟在 call 指令后
面的那条指令的地址。对应的指令 ret 会从栈中弹出地址 A,并把 PC 设置为 A。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-10%20233545.png)  
#### 3.7.3 数据传送
当调用一个过程时，除了要把控制传递给它沐在过程返回时再传递回来之外，过程调
用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。  
当过程 P 调用过程 Q 时，P 的代码必须首先
把参数复制到适当的寄存器中。类似地，当 Q 返回到 P 时，P 的代码可以访问寄存器％rax中的返回值。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-10%20234045.png)  
```C
void proc(long al, long *alp,
          int a2, int *a2p,
          short a3, short *a3p,
          char a4, char *a4p)
{
          *a1p += al;
	  *a2p += a2;
	  *a3p += a3;
	  *a4p += a4;
}
```
```
void proc(al, alp, a2, a2p, a3, a3p, a4, a4p)
Arguments passed as fellows:
al in %rdi          (64 bits)
alp in %rsi         (64 bits)
a2 in %edx          (32 bits)
a2p in %rcx         (64 bits)
a3 in %r8w          (16 bits)
a3p in %r9          (64 bits)
a4 at %rsp+8        ( 8 bits)
a4p at %rsp+16      (64 bits)

proc:
  movq   16(%rsp), %rax
  addq   %rdi, (%rsi)
  addl   %edx, (%rcx)
  addw   %r8w, (%r9)
  movl   8(%rsp), %edx
  addb   %dl, (%rax)
  ret 
```
#### 3.7.4 栈上的局部存储
到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不
过有些时候，局部数据必须存放在内存中，常见的情况包括：

    • 寄存器不足够存放所有的本地数据。
    • 对一个局部变量使用地址运算符 ‘&’， 因此必须能够为它产生一个地址。
    • 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。
函数 swap_add 交换
指针 xp 和 yp 指向的两个值，并返回这两个值的和。函数 caller 创建到局部变量 argl
和 arg2 的指针，把它们传递给 swap_add。
```C
long swap_add(long *xp, long *yp)
{
	long x = *xp;
	long y = *yp;
	*xp = y;
	*yp = x;
	return x + y;
}

long caller()
{
	long argl = 534;
	long arg2 = 1057;
	long sun = swap_add(&arg1, &arg2);
	long diff = argl - arg2;
	return sum * diff;
}
```
caller 的代码开6的时候把栈指针减掉了 16; 实际上这就是在栈上分
配了 16 个字节。S 表示栈指针的值，可以看到这段代码计算 &arg2 为 S+8(第 5 行），而
&argl 为 S 。 因此可以推断局部变量 argl 和 arg2 存放在栈帧中相对于栈指针偏移量为 0
和 8 的地方。当对 swap_add 的调用完成后，caller 的代码会从栈上取出这两个值（第
8 9 行）， 计算它们的差，再乘以 swap_add 在寄存器 %rax 中返回的值（第 10 行）。 最后，
该函数把找指针加 16, 释放栈帧(第 11 行）。 
```
caller:
   subq   $16, %rsp       
   movq   $534, (%rsp)
   movq   $1057, 8(%rsp)
   leaq   8(%rsp), %rsi
   movq   %rsp, %rdi
   call   swap_add
   movq   (%rsp), %rdx
   subq   8(%rsp), %rdx
   imulq  %rdx, %rax
   addq   $16, %rsp
   ret
```
#### 3.7.4 寄存器中的局部存储空间
寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一
个过程(被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，X86-64 采
用了一组统一的寄存器使用惯例，所有的过程(包括程序库)都必须遵循。
根据惯例，寄存器%rbx,%rbp和％r12〜％r15被划分为被调用者保存寄存器。当过程 P 
调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时
是一样的。过程 Q 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始
值压人栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压人寄存器的值会在栈帧
中创建标号为 “保存的寄存器”的一部分。有了这条惯例，P 的代码就
能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上）， 调用 Q，
然后继续使用寄存器中的值，不用担心值被破坏。  
所有其他的寄存器，除了栈指针％rsP，都分类为调用者保存寄存器。这就意味着任何
函数都能修改它们。可以这样来理解“调用者保存”这个名字：过程 P 在某个此类寄存器
中有局部数据，然后调用过程 Q 。 因为 Q 可以随意修改这个寄存器，所以在调用之前首先
保存好这个数据是 P(调用者）的责任。
```C
long P(long X，long y)
{
	long u = Q(y);
	long v = Q(x);
	return u+v;
}
```
```
P:
  pushq  %rbp          Save %rbp
  pushq  %rbx          Save %rbx
  subq   $8, %rsp      Align stack frame
  movq   %rdi, %rbp    Save x
  movq   %rsi, %rdi    Move y to first argument
  call   Q             Call Q(y)
  movq   %rax, %rbx    Save result
  movq   %rbp, %rdi    Move x to first argument
  call   Q             Call Q(y)
  addqc  %rbx, %rax    Add saved Q(y) to Q(x)'
  addq   $8, %rsp      Deallocate last part of stack
  popq   %rbx          Restore %rbx
  popq   %rbp          Restore %rbp
  ret
```
#### 3.7.6 递归过程
可以看到汇编代码使用
寄存器 * rbx 来保存参数 n, 先把已有的值保存在栈上（第 2 行）， 随后在返回前恢复该值
(第 11 行）。 根据栈的使用特性和寄存器保存规则，可以保证当递归调用 rfact(n-l)返回
时(第 9 行），（1)该次调用的结果会保存在寄存器％rax 中，（2)参数 n 的值仍然在寄存
S%rbx 中。把这两个值相乘就能得到期望的结果。
从这个例子我们可以看到，递归调用一个函数本身与调用其他函数是一样的。栈规则
提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者
保存寄存器的值)存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然地就与函数调用-返回的顺序匹配。这种实现函数调用和返回的
方法甚至对更复杂的情况也适用，包括相互递归调用（例如，过程 P 调用 Q, Q 再调用 P)。
```C
long rfact(long n)
{
	long result;
	if (n <= 1)
		result = 1;
	else
		result = n * rfact(n-l);
	return result;
}
```
```
rfact:
  pushq   %rbx             Save %rbx
  movq    %rdi，%rbx       Store n in callee-saved register
  movl    $1, %eax         Set return value = 1
  cmpq    $1, %rdi         Compare n:1
  jle     .L35             If <=, goto done
  leaq    -l(%rdi), %rdi   Compute n-1
  call    rfact            Call rfact(n-1)
  imulq   %rbx, %rax       Multiply result by n
 .L35:                    done:
  popq    %rbx             Restore %rbx
  ret                      Return
```
