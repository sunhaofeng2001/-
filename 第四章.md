第四章、处理器体系结构 
============
#### 写在前面
处理器必须执行一系列指令，每条指令执行某个简单操作，例如两个数相加。指令被编码为由一个或多
个字节序列组成的二进制格式。一个处理器支持的指令和指令的字节级编码称为它的指令
集体系结构（Instruction-Set Architecture ISA)。  
ISA 模型看上去应该是顺序指令执行，也就是先取出一条指令，等到它执行完毕，再开始
下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处
理器可以获得更高的性能。 
#### 4.1 Y86-64指令集体系结构
定义一个指令集体系结构（例如 Y86-64)包括定义各种状态单元、指令集和它们的编
码、一组编程规范和异常事件处理。
#### 4.1.1 程序员可见的状态
Y86-64 程序中的每条指令都会读取或修改处理器状态的某些部分。这
称为程序员可见状态，这里的“程序员”既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。  
寄存S%rsp 被人栈、出栈、调用和返回指令作为栈指针。除此之外，寄存器没有固定的含义或固定值。  
有 3 个一位的条件码：ZF SF 和 OF它们保存着最近的算术或逻辑指令所造成影响的有关信息。  
程序计数器（PC)存放当前正在执行指令的地址。  
内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64 程序用虚
拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地
址，指明数据实际存在内存中哪个地方。    
程序状态的最后一个部分是状态码 Stat 它表明程序执行的总体状态。它会指示是
正常运行，还是出现了某种异常。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20154656.png)  
#### 4.1.2 Y86-64 指令
Y86-64 指令集基本上是 x86-64 指令集的一个子集。它只包括 8 字节整数操作，
寻址方式较少，操作也较少。
• x86-64 的 movq 指令分成了 4 个不同的指令：imovq rrmovq mrmovq 和 rmmovq ，
  源可以是立即数（i)、寄存器（r)或内存（m)。指令字的第一个字母就表明了源的类型。目的可以是寄存器（r)或内存(m) 指令名字的
  第二个字母指明了目的的类型。两个内存传送指令中的内存引用方式是简单的基址和偏移量形式。  
• 有 4 个整数操作指令，它们是 addq subq andq 和 xorq它们只对寄存器数据进行操作，这些指令会设置 3 个条件码 ZF SF 和 OF(零、符号和溢出）。  
• 7 个跳转指令是 jmp jle jl je jne jge 和 jg。分支条件和 x86-64 的一样。  
• 有 6 个条件传送指令cmovle cmovl cmove cmovne cmovge cmovg   
• call 指令将返回地址人栈，然后跳到目的地址。ret 指令从这样的调用中返回。  
• pushq 和 popq 指令实现了入栈和出栈，就像在 x86-64 中一样。
• halt 指令停止指令的执行。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20160924.png)
#### 4.1.3 指令编码
图 4-2 还给出了指令的字节级编码。每条指令需要 1 10 个字节不等，这取决于需要
哪些字段。每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4位：高 4 位是代码（code)部分，低 4 位是功能（function)部分。
功能值只有在一组相关指令共用一个代码时才有用。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20161534.png)  
15 个程序寄存器中每个都有一个相对应的范围在 0 到 0xE 之间的寄存器标识符。10)。丫86-64中的寄存器编号跟乂86-64中的相同。程序寄存器存在
CPU 中的一个寄存器文件中，这个寄存器文件就是一个小的、以寄存器 ID 作为地址的随
机访问存储器。在指令编码中以及在我们的硬件设计中，当需要指明不应访问任何寄存器
时，就用 ID 值 OxF 来表示。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20161635.png)
指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一
个唯一的指令序列的编码，要么就不是一个合法的字节序列。这个性质保证了处理器可以无二义性地执行目标代码程
序。即使代码嵌人在程序的其他字节中，只要从序列的第一个字节开始处理，我们仍然可
以很容易地确定指令序列。
#### 4.1.4 Y86-64 异常
对 Y86-64 来说，程序员可见的状态包括状态码 Stat, 它描述程序执行的总体状态。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20161931.png)  
对于 Y86-64, 当 遇到这些异常的时候，我们就简单地让处理器停止执行指令。在更完整的
设计中，处理器通常会调用一个异常处理程序这个过程被指定用来处理遇到的某种类型的异常。  
#### 4.1.5 Y86-64 程序
```C
long sum(long *start, long count)
{
   long sum = 0;
   while (count) {
      sum += *start;
      start++;
      count--;
   }
   return sum;
}
```
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20162809.png)  
不同点：Y86-64 将常数加载到寄存器(第 2 3 行）， 因为它在算术指令中不能使用立即数。  
要实现从内存读取一个数值并将其与一个寄存器相加，Y86-64 代码需要两条指令(第 8 9 行），而 X86-64 只需要一条 addq指令（第 5 行）。  
Y86-64 实现有一个优势，即 subq 指令（第 11 行）同时还设置了条件码，因此 GCC 生成代码中的 testq 指令（第 9 行）就不是必需的。不过为此，
Y86-64 代码必须用 andq 指令(第 5 行）在进人循环之前设置条件码。
#### 4.1.6 一些 Y86-64 指令的详情
大多数 Y86-64 指令是以一种直接明了的方式修改程序状态的，所以定义每条指令想
要达到的结果并不困难。不过，两个特别的指令的组合需要特别注意一下。pmshq 指令会把栈指针减 8, 并且将一个寄存器值写人内存中。因此，当执行 pushq
%rsP 指令时，处理器的行为是不确定的，因为要人栈的寄存器会被同一条指令修改。通
常有两种不同的约定： 1)压人％rsp 的原始值，2)压人减去 8的%rsp的值。
#### 4.2 逻辑设计和硬件控制语言 HCL
#### 4.2.1 逻辑门
逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输人位值的某个布尔函数。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20164235.png)  
逻辑门总是活动的（active), —旦一个门的输人变化了，在很短的时间内，输出就会相应地变化。  
#### 4.2.2 组合电路和 HCL 布尔表达式
将很多的逻辑门组合成一个网，就能构建计算块（computational block), 称为组合电路(combinational circuits)。
•每个逻辑门的输入必须连接到下述选项之一：1)一个系统输入（称为主输人）， 2)某
个存储器单元的输出，3)某个逻辑门的输出。  
•两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可
能会导致一个不合法的电压或电路故障。  
•这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，
这样的回路会导致该网络计算的函数有歧义。  
#### 4.2.3 字级的组合电路和 HCL 整数表达式
通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常，我
们设计能对数据字（word)进行操作的电路。有一些位级信号，代表一个整数或一些控制模式。例如，我们的处理器设计将包含有很多字，字的大小的范围为 4 位到 64 位，代表整数、地址、指令代码和寄存器标识符。  
执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。
一个组合电路，它测试两个 64 位字 A 和 B 是否相等。也就是，当且仅当 A 的每
一位都和 B 的相应位相等时，输出才为 1。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20165111.png)    
在 HCL 中，我们将所有字级的信号都声明为 int。不指定字的大小。这样做是为了
简单。在全功能的硬件描述语言中，每个字都可以声明为有特定的位数。  
组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作。具体的设计已经超
出了我们讨论的范围。算术/逻辑单元（ALU)是一种很重要的组合电路，这个电路有三个输入：标号为 A 和 B 的两个数据输人，以及一个控制输
人。根据控制输入的设置，电路会对数据输入执行不同的算术或逻辑操作。可以看到，这
个 ALU 中画的四个操作对应于 Y86-64 指令集支持的四种不同的整数操作，而控制值和这
些操作的功能码相对应（图 4-3)。我们还注意到减法的操作数顺序，是输人 B 减去输入 A。
之所以这样做，是为了使这个顺序与 subq 指令的参数顺序一致。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20165432.png)  
#### 4.2.4 集合关系
在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来
检测正在处理的某个指令代码是否属于某一类指令代码。一个两位信号 code 中选择高位和低位来为四路复用器产生信号 s1 和 s2。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20165620.png)  
#### 4.2.5 存储器和时钟
组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输人信号，产生等
于输人的某个函数的输出。为了产生时序电路(sequential circuit), 也就是有状态并且在这个
状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制
的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：
时钟寄存器（简称寄存器)存储单个位或字。时钟信号控制寄存器加载输入值。
随机访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。随机访
问存储器的例子包括：1)处理器的虚拟内存系统，硬件和操作系统软件结合起来使
处理器用可以在一个很大的地址空间内访问任意的字；2)寄存器文件，在此，寄存器
标识符作为地址。在 IA32 或 Y86-64 处理器中，寄存器文件有 15 个程序寄存器（%rax
~%rl4)。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20170109.png)  
寄存器文件有两个读端口（A 和 B), 还有一个写端口（W)。这样一个多 端口随机访问存储器允许词时进行多个读和写操作。
图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态，每个端口都有一个地址输人，表明该选择哪个
程序寄存器，另外还有一个数据输出或对盧该程序寄存器的输入值。两个读端口有地址输人 sre兵和 srcB( “source A和 “source B
的缩写）和数据输出 valA 和 valB(valueA和valueB的缩写）。 写端口有地址输人
dstW( “destination W的缩写）, 以及数据输人 valw( “value W的缩写）。
虽然寄存器文件不是组合电路，因为它有内部存储。不过，在我们的实现中，从寄存
器文件读数据就好像它是一个以地址为输人、数据为输出的一个组合逻辑块。当 srcA 或
srcB 被设成某个寄存器 ID 时，在一段延迟之后，存储在相应程序寄存器的值就会出现在
valA 或 valB 上。  
向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每
次时钟上升时，输人 valW 上的值会被写人输入 dstW 上的寄存器 ID 指示的程序寄存器。当
dstW 设为特殊的 ID 值 OxF 时，不会写任何程序寄存器。由于寄存器文件既可以读也可以写，
一个很自然的问题就是“如果我们试图同时读和写同一个寄存器会发生什么?”答案简单明了：
如果更新一个寄存器，同时在读端口上用同一个寄存器 ID。 我们会看到一个从旧值到新值的变
化。当我们把这个寄存器文件加入到处理器设计中，我们保证会考虑到这个属性的。
处理器有一个随机访问存储器来存储程序数据，如下图所示：  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20170518.png)  
这个内存有一个地址输人，一个写的数据输入，以及一个读的数据输出。同寄存器文件
一样，从内存中读的操作方式类似于组合逻辑：如果我们在输入 address 上提供一个地址,
并将 write 控制信号设置为 0, 那么在经过一些延迟之后，存储在那个地址上的值会出现在输出 data 上。如果地址超出了范围，
error 信号会设置为 1，否则就设置为 0。写内存是由时钟控制的：我们将 address 设置为期望的地址，将 data in 设置为期望的值，而 write 设
置为 1。然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。对于读
操作来说，如果地址是不合法的，error 信号会被设置为 1。这个信号是由组合逻辑产生的，因为所需要的边界检查纯粹就是地址输人的函数，不涉及保存任何状态。
#### 4.3 Y86-64 的顺序实现
现在已经有了实现 Y86-64 处理器所需要的部件。首先，我们描述一个称为 SEQ）的处理器。每个时钟周期上，SEQ 执行处理一条完整指令所需的所有步
骤。不过，这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受。
#### 4.3.1 将处理组织成阶段
将它们组织成某个特殊的阶段序列，即使指令的
动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指
令。

    • 取指(fetch): 取指阶段从内存读取指令字节，地址为程序计数器（PC)的值。从指
    令中抽取出指令指示符字节的两个四位部分，称为 icode(指令代码）和 ifun(指令
    功能）。 它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符
    rA 和 rB。它还可能取出一个四字节常数字 valC。它按顺序方式计算当前指令的下
    一条指令的地址 valP。也就是说，valP 等于 PC 的值加上已取出指令的长度。
    • 译码（decode): 译码阶段从寄存器文件读人最多两个操作数，得到值 valA 和/或 valB。
    通常，它读人指令 rA 和 rB 字段指明的寄存器，不过有些指令是读寄存器%rsp 的。
    • 执行(execute): 在执行阶段，算术/逻辑单元（ALU)要么执行指令指明的操作（根
    据 ifun 的值）， 计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们
    称为 valE。在此，也可能设置条件码。对一条条件传送指令来说，这个阶段会检
    验条件码和传送条件（由 ifun 给出）， 如果条件成立，则更新目标寄存器。同样，
    对一条跳转指令来说，这个阶段会决定是不是应该选择分支。
    •访存(memory): 访存阶段可以将数据写入内存，或者从内存读出数据。读出的值
    为 valM。
    •写回（write back): 写回阶段最多可以写两个结果到寄存器文件。
    •更新 PC(PC update): 将 PC 设置成下一条指令的地址。
#### 4.3.2 SEQ 硬件结构
实现所有 Y86-64 指令所需要的计算可以 写回被组织成 6 个基本阶段：取指、译码、执行、访存、写回和更新 PC。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20212831.png)  

    •白色方框表示时钟寄存器。程序计数器 PC 是 SEQ 中唯一的时钟寄存器。
    •浅蓝色方框表示硬件单元。这包括内存、ALU 等等。在我们所有的处理器实现中，
    都会使用这一组基本的单元。我们把这些单元当作“黑盒子”， 不关心它们的细节
    设计。
    •控制逻辑块用灰色圆角矩形表示。这些块用来从一组信号源中进行选择，或者用来
    计算一些布尔函数。我们会非常详细地分析这些块，包括给出 HCL 描述。
    •线路的名字在白色圆圈中说明。它们只是线路的标识，而不是什么硬件单元。
    •宽度为字 长的数据连接用中等粗度的 线表示。每条这样的线实际上都代表一簇 64
    根线，并列地连在一起，将一个字从硬件的一个部分传送到另一部分。
    •宽度为 字节或更窄的数据连接用细线表示。根据线上要携带的值的类型，每条这样
    的线实际上都代表一簇 4 根或 8 根线。
    •单个位的连接用虚线来表示。这代表芯片上单元与块之间传递的控制值。
#### 4.3.3 SEQ 的时序
SEQ 的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件码寄存
器）， 随机访问存储器(寄存器文件、指令内存和数据内存）。组合逻辑不需要任何时序或
控制棗 只要输入变化了，值就通过逻辑门网络传播。  
四个硬件单元需要对它们的时序进行明确的控制棗 程序计数器、条件码寄
存器、数据内存和寄存器文件。每个时钟周期，程序计数器都会装载新的指令地
址。只有在执行整数运算指令时，才会装载条件码寄存器。只有在执行 rmmovq,pushq
或 Call 指令时，才会写数据内存。寄存器文件的两个写端口允许每个时钟周期更新两个
程序寄存器，不过我们可以用特殊的寄存器 ID 〇XF 作为端口地址，来表明在此端口不应
该执行写操作。  
标号为 1 4 的各个图给出了 4 个状态单元，还有组合逻辑，以及状态单元之间的连
接。组合逻辑被条件码寄存器环绕着，因为有的组合逻辑（例如 ALU)产生输人到条件码
寄存器，而其他部分(例如分支计算和 PC 选择逻辑）又将条件码寄存器作为输人。图中寄
存器文件和数据内存有独立的读连接和写连接，因为读操作沿着这些单元传播，就好像它
们是组合逻辑，而写操作是由时钟控制的。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20213847.png)  
#### 4.3.4 SEQ 阶段的实现
1. 取指阶段  取指阶段包括指令内存硬件单元。以 PC 作为第一个字节（字节 0)的
地址，这个单元一次从内存读出 10 个字
节。第一个字节被解释成指令字节，（标
号为Split的单元）分为两个 4 位的
数。然后，标 号为 icode 和 ifun
的控制逻辑块计算指令和功能码，或者
使之等于从内存读出的值，或者当指令
地址不合法时， 使这些值对应于 nop 指令。
![image]()
2. 译码和写回阶段  实现译码和写回阶段的逻辑的详细情况。把这两个阶段联系在
一起是因为它们都要访问寄存器文件。
寄存器文件有四个端口。它支持同时进行两个读(在端口 A 和 B 上）和两个写（在端口
E 和 M 上）。 每个端口都有一个地址连接和一个数据
连接，地址连接是一个寄存器 ID, 而数据连接是一
组 64 根线路，既可以作为寄存器文件的输出字（对读
端口来说）， 也可以作为它的输人字（对写端口来说）。
两个读端口的地址输入为 srcA 和 srcB, 而两个写端
口的地址输人为 dstE 和 dstM。如果某个地址端口上
的值为特殊标识符 OxF(RNONE), 则表明不需要访问
寄存器。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20214616.png)  
3. 执行阶段  执行阶段包括算术/逻辑单元（ALU)。这个单
元根据 al.ufun 信号的设置，对输入 aluA 和 aluB
执行 ADD SUBTRACT AND 或 EXCLUSIVE0R 运算。
ALU 的输出就是 valS
信号。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20214733.png)  
4. 访存阶段  访存阶段的任务就是读或者写程 序数据。如
图 所示，两个控制块产生内存地址和内存输人
数据（为写操作）的值。另外两个块产生表明应该执
行读操作还是写操作的控制信号。当执行读操作时，
数据内存产生值 valM。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20214933.png)  
5. 更新 PC 阶段  SEQ 中最后一个阶段会产生程序计数器的新值。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20215100.png)  
6. SEQ 小结 通过将执行每条
不同指令所需的步骤组织成一个统一的流程，就可以用很少量的各种硬件单元以及一个时
钟来控制计算的顺序，从而实现整个处理器。不过这样一来，控制逻辑就必须要在这些单
元之间路由信号，并根据指令类型和分支条件产生适当的控制信号。SEQ 唯一的问题就是它太慢了。时钟必须非常慢，以使信号能在一个周期内传播所
有的阶段。这种实现方法不能充分利用硬件单元，因为每个单元只在整个时钟周期的一部分时间
内才被使用。我们会看到引入流水线能获得更好的性能。 
#### 4.4 流水线的通用原理
流水线化的一个重要特性就是提高了系统的吞吐量（throughput), 也就是单位时间内
服务的顾客总数，不过它也会轻微地增加延迟（latency), 也就是服务一个用户所需要的时
间。

