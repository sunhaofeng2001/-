第四章、处理器体系结构 
============
#### 写在前面
处理器必须执行一系列指令，每条指令执行某个简单操作，例如两个数相加。指令被编码为由一个或多
个字节序列组成的二进制格式。一个处理器支持的指令和指令的字节级编码称为它的指令
集体系结构（Instruction-Set Architecture ISA)。  
ISA 模型看上去应该是顺序指令执行，也就是先取出一条指令，等到它执行完毕，再开始
下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处
理器可以获得更高的性能。 
#### 4.1 Y86-64指令集体系结构
定义一个指令集体系结构（例如 Y86-64)包括定义各种状态单元、指令集和它们的编
码、一组编程规范和异常事件处理。
#### 4.1.1 程序员可见的状态
Y86-64 程序中的每条指令都会读取或修改处理器状态的某些部分。这
称为程序员可见状态，这里的“程序员”既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。  
寄存S%rsp 被人栈、出栈、调用和返回指令作为栈指针。除此之外，寄存器没有固定的含义或固定值。  
有 3 个一位的条件码：ZF SF 和 OF它们保存着最近的算术或逻辑指令所造成影响的有关信息。  
程序计数器（PC)存放当前正在执行指令的地址。  
内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64 程序用虚
拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地
址，指明数据实际存在内存中哪个地方。    
程序状态的最后一个部分是状态码 Stat 它表明程序执行的总体状态。它会指示是
正常运行，还是出现了某种异常。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20154656.png)  
#### 4.1.2 Y86-64 指令
Y86-64 指令集基本上是 x86-64 指令集的一个子集。它只包括 8 字节整数操作，
寻址方式较少，操作也较少。
• x86-64 的 movq 指令分成了 4 个不同的指令：imovq rrmovq mrmovq 和 rmmovq ，
  源可以是立即数（i)、寄存器（r)或内存（m)。指令字的第一个字母就表明了源的类型。目的可以是寄存器（r)或内存(m) 指令名字的
  第二个字母指明了目的的类型。两个内存传送指令中的内存引用方式是简单的基址和偏移量形式。  
• 有 4 个整数操作指令，它们是 addq subq andq 和 xorq它们只对寄存器数据进行操作，这些指令会设置 3 个条件码 ZF SF 和 OF(零、符号和溢出）。  
• 7 个跳转指令是 jmp jle jl je jne jge 和 jg。分支条件和 x86-64 的一样。  
• 有 6 个条件传送指令cmovle cmovl cmove cmovne cmovge cmovg   
• call 指令将返回地址人栈，然后跳到目的地址。ret 指令从这样的调用中返回。  
• pushq 和 popq 指令实现了入栈和出栈，就像在 x86-64 中一样。
• halt 指令停止指令的执行。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20160924.png)
#### 4.1.3 指令编码
图 4-2 还给出了指令的字节级编码。每条指令需要 1 10 个字节不等，这取决于需要
哪些字段。每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4位：高 4 位是代码（code)部分，低 4 位是功能（function)部分。
功能值只有在一组相关指令共用一个代码时才有用。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20161534.png)  
15 个程序寄存器中每个都有一个相对应的范围在 0 到 0xE 之间的寄存器标识符。10)。丫86-64中的寄存器编号跟乂86-64中的相同。程序寄存器存在
CPU 中的一个寄存器文件中，这个寄存器文件就是一个小的、以寄存器 ID 作为地址的随
机访问存储器。在指令编码中以及在我们的硬件设计中，当需要指明不应访问任何寄存器
时，就用 ID 值 OxF 来表示。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20161635.png)
指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一
个唯一的指令序列的编码，要么就不是一个合法的字节序列。这个性质保证了处理器可以无二义性地执行目标代码程
序。即使代码嵌人在程序的其他字节中，只要从序列的第一个字节开始处理，我们仍然可
以很容易地确定指令序列。
#### 4.1.4 Y86-64 异常
对 Y86-64 来说，程序员可见的状态包括状态码 Stat, 它描述程序执行的总体状态。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20161931.png)  
对于 Y86-64, 当 遇到这些异常的时候，我们就简单地让处理器停止执行指令。在更完整的
设计中，处理器通常会调用一个异常处理程序这个过程被指定用来处理遇到的某种类型的异常。  
#### 4.1.5 Y86-64 程序
```C
long sum(long *start, long count)
{
   long sum = 0;
   while (count) {
      sum += *start;
      start++;
      count--;
   }
   return sum;
}
```
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20162809.png)  
不同点：Y86-64 将常数加载到寄存器(第 2 3 行）， 因为它在算术指令中不能使用立即数。  
要实现从内存读取一个数值并将其与一个寄存器相加，Y86-64 代码需要两条指令(第 8 9 行），而 X86-64 只需要一条 addq指令（第 5 行）。  
Y86-64 实现有一个优势，即 subq 指令（第 11 行）同时还设置了条件码，因此 GCC 生成代码中的 testq 指令（第 9 行）就不是必需的。不过为此，
Y86-64 代码必须用 andq 指令(第 5 行）在进人循环之前设置条件码。
#### 4.1.6 一些 Y86-64 指令的详情
大多数 Y86-64 指令是以一种直接明了的方式修改程序状态的，所以定义每条指令想
要达到的结果并不困难。不过，两个特别的指令的组合需要特别注意一下。pmshq 指令会把栈指针减 8, 并且将一个寄存器值写人内存中。因此，当执行 pushq
%rsP 指令时，处理器的行为是不确定的，因为要人栈的寄存器会被同一条指令修改。通
常有两种不同的约定： 1)压人％rsp 的原始值，2)压人减去 8的%rsp的值。
#### 4.2 逻辑设计和硬件控制语言 HCL
#### 4.2.1 逻辑门
逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输人位值的某个布尔函数。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20164235.png)  
逻辑门总是活动的（active), —旦一个门的输人变化了，在很短的时间内，输出就会相应地变化。  
#### 4.2.2 组合电路和 HCL 布尔表达式
将很多的逻辑门组合成一个网，就能构建计算块（computational block), 称为组合电路(combinational circuits)。
•每个逻辑门的输入必须连接到下述选项之一：1)一个系统输入（称为主输人）， 2)某
个存储器单元的输出，3)某个逻辑门的输出。  
•两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可
能会导致一个不合法的电压或电路故障。  
•这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，
这样的回路会导致该网络计算的函数有歧义。  
#### 4.2.3 字级的组合电路和 HCL 整数表达式
通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常，我
们设计能对数据字（word)进行操作的电路。有一些位级信号，代表一个整数或一些控制模式。例如，我们的处理器设计将包含有很多字，字的大小的范围为 4 位到 64 位，代表整数、地址、指令代码和寄存器标识符。  
执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。
一个组合电路，它测试两个 64 位字 A 和 B 是否相等。也就是，当且仅当 A 的每
一位都和 B 的相应位相等时，输出才为 1。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20165111.png)    
在 HCL 中，我们将所有字级的信号都声明为 int。不指定字的大小。这样做是为了
简单。在全功能的硬件描述语言中，每个字都可以声明为有特定的位数。  
组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作。具体的设计已经超
出了我们讨论的范围。算术/逻辑单元（ALU)是一种很重要的组合电路，这个电路有三个输入：标号为 A 和 B 的两个数据输人，以及一个控制输
人。根据控制输入的设置，电路会对数据输入执行不同的算术或逻辑操作。可以看到，这
个 ALU 中画的四个操作对应于 Y86-64 指令集支持的四种不同的整数操作，而控制值和这
些操作的功能码相对应（图 4-3)。我们还注意到减法的操作数顺序，是输人 B 减去输入 A。
之所以这样做，是为了使这个顺序与 subq 指令的参数顺序一致。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20165432.png)  
#### 4.2.4 集合关系
在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来
检测正在处理的某个指令代码是否属于某一类指令代码。一个两位信号 code 中选择高位和低位来为四路复用器产生信号 s1 和 s2。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20165620.png)  
#### 4.2.5 存储器和时钟
组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输人信号，产生等
于输人的某个函数的输出。为了产生时序电路(sequential circuit), 也就是有状态并且在这个
状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制
的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：
时钟寄存器（简称寄存器)存储单个位或字。时钟信号控制寄存器加载输入值。
随机访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。随机访
问存储器的例子包括：1)处理器的虚拟内存系统，硬件和操作系统软件结合起来使
处理器用可以在一个很大的地址空间内访问任意的字；2)寄存器文件，在此，寄存器
标识符作为地址。在 IA32 或 Y86-64 处理器中，寄存器文件有 15 个程序寄存器（%rax
~%rl4)。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20170109.png)  
寄存器文件有两个读端口（A 和 B), 还有一个写端口（W)。这样一个多 端口随机访问存储器允许词时进行多个读和写操作。
图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态，每个端口都有一个地址输人，表明该选择哪个
程序寄存器，另外还有一个数据输出或对盧该程序寄存器的输入值。两个读端口有地址输人 sre兵和 srcB( “source A和 “source B
的缩写）和数据输出 valA 和 valB(valueA和valueB的缩写）。 写端口有地址输人
dstW( “destination W的缩写）, 以及数据输人 valw( “value W的缩写）。
虽然寄存器文件不是组合电路，因为它有内部存储。不过，在我们的实现中，从寄存
器文件读数据就好像它是一个以地址为输人、数据为输出的一个组合逻辑块。当 srcA 或
srcB 被设成某个寄存器 ID 时，在一段延迟之后，存储在相应程序寄存器的值就会出现在
valA 或 valB 上。  
向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每
次时钟上升时，输人 valW 上的值会被写人输入 dstW 上的寄存器 ID 指示的程序寄存器。当
dstW 设为特殊的 ID 值 OxF 时，不会写任何程序寄存器。由于寄存器文件既可以读也可以写，
一个很自然的问题就是“如果我们试图同时读和写同一个寄存器会发生什么?”答案简单明了：
如果更新一个寄存器，同时在读端口上用同一个寄存器 ID。 我们会看到一个从旧值到新值的变
化。当我们把这个寄存器文件加入到处理器设计中，我们保证会考虑到这个属性的。
处理器有一个随机访问存储器来存储程序数据，如下图所示：  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20170518.png)  
这个内存有一个地址输人，一个写的数据输入，以及一个读的数据输出。同寄存器文件
一样，从内存中读的操作方式类似于组合逻辑：如果我们在输入 address 上提供一个地址,
并将 write 控制信号设置为 0, 那么在经过一些延迟之后，存储在那个地址上的值会出现在输出 data 上。如果地址超出了范围，
error 信号会设置为 1，否则就设置为 0。写内存是由时钟控制的：我们将 address 设置为期望的地址，将 data in 设置为期望的值，而 write 设
置为 1。然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。对于读
操作来说，如果地址是不合法的，error 信号会被设置为 1。这个信号是由组合逻辑产生的，因为所需要的边界检查纯粹就是地址输人的函数，不涉及保存任何状态。
#### 4.3 Y86-64 的顺序实现
现在已经有了实现 Y86-64 处理器所需要的部件。首先，我们描述一个称为 SEQ）的处理器。每个时钟周期上，SEQ 执行处理一条完整指令所需的所有步
骤。不过，这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受。
#### 4.3.1 将处理组织成阶段
