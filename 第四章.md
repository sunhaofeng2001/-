第四章、处理器体系结构 
============
#### 写在前面
处理器必须执行一系列指令，每条指令执行某个简单操作，例如两个数相加。指令被编码为由一个或多
个字节序列组成的二进制格式。一个处理器支持的指令和指令的字节级编码称为它的指令
集体系结构（Instruction-Set Architecture ISA)。  
ISA 模型看上去应该是顺序指令执行，也就是先取出一条指令，等到它执行完毕，再开始
下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处
理器可以获得更高的性能。 
#### 4.1 Y86-64指令集体系结构
定义一个指令集体系结构（例如 Y86-64)包括定义各种状态单元、指令集和它们的编
码、一组编程规范和异常事件处理。
#### 4.1.1 程序员可见的状态
Y86-64 程序中的每条指令都会读取或修改处理器状态的某些部分。这
称为程序员可见状态，这里的“程序员”既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。  
寄存S%rsp 被人栈、出栈、调用和返回指令作为栈指针。除此之外，寄存器没有固定的含义或固定值。  
有 3 个一位的条件码：ZF SF 和 OF它们保存着最近的算术或逻辑指令所造成影响的有关信息。  
程序计数器（PC)存放当前正在执行指令的地址。  
内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64 程序用虚
拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地
址，指明数据实际存在内存中哪个地方。    
程序状态的最后一个部分是状态码 Stat 它表明程序执行的总体状态。它会指示是
正常运行，还是出现了某种异常。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20154656.png)  
#### 4.1.2 Y86-64 指令
Y86-64 指令集基本上是 x86-64 指令集的一个子集。它只包括 8 字节整数操作，
寻址方式较少，操作也较少。
• x86-64 的 movq 指令分成了 4 个不同的指令：imovq rrmovq mrmovq 和 rmmovq ，
  源可以是立即数（i)、寄存器（r)或内存（m)。指令字的第一个字母就表明了源的类型。目的可以是寄存器（r)或内存(m) 指令名字的
  第二个字母指明了目的的类型。两个内存传送指令中的内存引用方式是简单的基址和偏移量形式。  
• 有 4 个整数操作指令，它们是 addq subq andq 和 xorq它们只对寄存器数据进行操作，这些指令会设置 3 个条件码 ZF SF 和 OF(零、符号和溢出）。  
• 7 个跳转指令是 jmp jle jl je jne jge 和 jg。分支条件和 x86-64 的一样。  
• 有 6 个条件传送指令cmovle cmovl cmove cmovne cmovge cmovg   
• call 指令将返回地址人栈，然后跳到目的地址。ret 指令从这样的调用中返回。  
• pushq 和 popq 指令实现了入栈和出栈，就像在 x86-64 中一样。
• halt 指令停止指令的执行。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20160924.png)
#### 4.1.3 指令编码
图 4-2 还给出了指令的字节级编码。每条指令需要 1 10 个字节不等，这取决于需要
哪些字段。每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4位：高 4 位是代码（code)部分，低 4 位是功能（function)部分。
功能值只有在一组相关指令共用一个代码时才有用。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20161534.png)  
15 个程序寄存器中每个都有一个相对应的范围在 0 到 0xE 之间的寄存器标识符。10)。丫86-64中的寄存器编号跟乂86-64中的相同。程序寄存器存在
CPU 中的一个寄存器文件中，这个寄存器文件就是一个小的、以寄存器 ID 作为地址的随
机访问存储器。在指令编码中以及在我们的硬件设计中，当需要指明不应访问任何寄存器
时，就用 ID 值 OxF 来表示。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20161635.png)
指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一
个唯一的指令序列的编码，要么就不是一个合法的字节序列。这个性质保证了处理器可以无二义性地执行目标代码程
序。即使代码嵌人在程序的其他字节中，只要从序列的第一个字节开始处理，我们仍然可
以很容易地确定指令序列。
#### 4.1.4 Y86-64 异常
对 Y86-64 来说，程序员可见的状态包括状态码 Stat, 它描述程序执行的总体状态。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20161931.png)  
对于 Y86-64, 当 遇到这些异常的时候，我们就简单地让处理器停止执行指令。在更完整的
设计中，处理器通常会调用一个异常处理程序这个过程被指定用来处理遇到的某种类型的异常。  
#### 4.1.5 Y86-64 程序
```C
long sum(long *start, long count)
{
   long sum = 0;
   while (count) {
      sum += *start;
      start++;
      count--;
   }
   return sum;
}
```
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20162809.png)  
不同点：Y86-64 将常数加载到寄存器(第 2 3 行）， 因为它在算术指令中不能使用立即数。  
要实现从内存读取一个数值并将其与一个寄存器相加，Y86-64 代码需要两条指令(第 8 9 行），而 X86-64 只需要一条 addq指令（第 5 行）。  
Y86-64 实现有一个优势，即 subq 指令（第 11 行）同时还设置了条件码，因此 GCC 生成代码中的 testq 指令（第 9 行）就不是必需的。不过为此，
Y86-64 代码必须用 andq 指令(第 5 行）在进人循环之前设置条件码。
#### 4.1.6 一些 Y86-64 指令的详情
大多数 Y86-64 指令是以一种直接明了的方式修改程序状态的，所以定义每条指令想
要达到的结果并不困难。不过，两个特别的指令的组合需要特别注意一下。pmshq 指令会把栈指针减 8, 并且将一个寄存器值写人内存中。因此，当执行 pushq
%rsP 指令时，处理器的行为是不确定的，因为要人栈的寄存器会被同一条指令修改。通
常有两种不同的约定： 1)压人％rsp 的原始值，2)压人减去 8的%rsp的值。
#### 4.2 逻辑设计和硬件控制语言 HCL
#### 4.2.1 逻辑门
逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输人位值的某个布尔函数。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20164235.png)  
逻辑门总是活动的（active), —旦一个门的输人变化了，在很短的时间内，输出就会相应地变化。  
#### 4.2.2 组合电路和 HCL 布尔表达式
将很多的逻辑门组合成一个网，就能构建计算块（computational block), 称为组合电路(combinational circuits)。
•每个逻辑门的输入必须连接到下述选项之一：1)一个系统输入（称为主输人）， 2)某
个存储器单元的输出，3)某个逻辑门的输出。  
•两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可
能会导致一个不合法的电压或电路故障。  
•这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，
这样的回路会导致该网络计算的函数有歧义。  
#### 4.2.3 字级的组合电路和 HCL 整数表达式
通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常，我
们设计能对数据字（word)进行操作的电路。有一些位级信号，代表一个整数或一些控制模式。例如，我们的处理器设计将包含有很多字，字的大小的范围为 4 位到 64 位，代表整数、地址、指令代码和寄存器标识符。  
执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。
一个组合电路，它测试两个 64 位字 A 和 B 是否相等。也就是，当且仅当 A 的每
一位都和 B 的相应位相等时，输出才为 1。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20165111.png)    
在 HCL 中，我们将所有字级的信号都声明为 int。不指定字的大小。这样做是为了
简单。在全功能的硬件描述语言中，每个字都可以声明为有特定的位数。  
组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作。具体的设计已经超
出了我们讨论的范围。算术/逻辑单元（ALU)是一种很重要的组合电路，这个电路有三个输入：标号为 A 和 B 的两个数据输人，以及一个控制输
人。根据控制输入的设置，电路会对数据输入执行不同的算术或逻辑操作。可以看到，这
个 ALU 中画的四个操作对应于 Y86-64 指令集支持的四种不同的整数操作，而控制值和这
些操作的功能码相对应（图 4-3)。我们还注意到减法的操作数顺序，是输人 B 减去输入 A。
之所以这样做，是为了使这个顺序与 subq 指令的参数顺序一致。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20165432.png)  
#### 4.2.4 集合关系
在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来
检测正在处理的某个指令代码是否属于某一类指令代码。一个两位信号 code 中选择高位和低位来为四路复用器产生信号 s1 和 s2。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20165620.png)  
#### 4.2.5 存储器和时钟
组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输人信号，产生等
于输人的某个函数的输出。为了产生时序电路(sequential circuit), 也就是有状态并且在这个
状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制
的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：
时钟寄存器（简称寄存器)存储单个位或字。时钟信号控制寄存器加载输入值。
随机访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。随机访
问存储器的例子包括：1)处理器的虚拟内存系统，硬件和操作系统软件结合起来使
处理器用可以在一个很大的地址空间内访问任意的字；2)寄存器文件，在此，寄存器
标识符作为地址。在 IA32 或 Y86-64 处理器中，寄存器文件有 15 个程序寄存器（%rax
~%rl4)。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20170109.png)  
寄存器文件有两个读端口（A 和 B), 还有一个写端口（W)。这样一个多 端口随机访问存储器允许词时进行多个读和写操作。
图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态，每个端口都有一个地址输人，表明该选择哪个
程序寄存器，另外还有一个数据输出或对盧该程序寄存器的输入值。两个读端口有地址输人 sre兵和 srcB( “source A和 “source B
的缩写）和数据输出 valA 和 valB(valueA和valueB的缩写）。 写端口有地址输人
dstW( “destination W的缩写）, 以及数据输人 valw( “value W的缩写）。
虽然寄存器文件不是组合电路，因为它有内部存储。不过，在我们的实现中，从寄存
器文件读数据就好像它是一个以地址为输人、数据为输出的一个组合逻辑块。当 srcA 或
srcB 被设成某个寄存器 ID 时，在一段延迟之后，存储在相应程序寄存器的值就会出现在
valA 或 valB 上。  
向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每
次时钟上升时，输人 valW 上的值会被写人输入 dstW 上的寄存器 ID 指示的程序寄存器。当
dstW 设为特殊的 ID 值 OxF 时，不会写任何程序寄存器。由于寄存器文件既可以读也可以写，
一个很自然的问题就是“如果我们试图同时读和写同一个寄存器会发生什么?”答案简单明了：
如果更新一个寄存器，同时在读端口上用同一个寄存器 ID。 我们会看到一个从旧值到新值的变
化。当我们把这个寄存器文件加入到处理器设计中，我们保证会考虑到这个属性的。
处理器有一个随机访问存储器来存储程序数据，如下图所示：  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20170518.png)  
这个内存有一个地址输人，一个写的数据输入，以及一个读的数据输出。同寄存器文件
一样，从内存中读的操作方式类似于组合逻辑：如果我们在输入 address 上提供一个地址,
并将 write 控制信号设置为 0, 那么在经过一些延迟之后，存储在那个地址上的值会出现在输出 data 上。如果地址超出了范围，
error 信号会设置为 1，否则就设置为 0。写内存是由时钟控制的：我们将 address 设置为期望的地址，将 data in 设置为期望的值，而 write 设
置为 1。然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。对于读
操作来说，如果地址是不合法的，error 信号会被设置为 1。这个信号是由组合逻辑产生的，因为所需要的边界检查纯粹就是地址输人的函数，不涉及保存任何状态。
#### 4.3 Y86-64 的顺序实现
现在已经有了实现 Y86-64 处理器所需要的部件。首先，我们描述一个称为 SEQ）的处理器。每个时钟周期上，SEQ 执行处理一条完整指令所需的所有步
骤。不过，这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受。
#### 4.3.1 将处理组织成阶段
将它们组织成某个特殊的阶段序列，即使指令的
动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指
令。

    • 取指(fetch): 取指阶段从内存读取指令字节，地址为程序计数器（PC)的值。从指
    令中抽取出指令指示符字节的两个四位部分，称为 icode(指令代码）和 ifun(指令
    功能）。 它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符
    rA 和 rB。它还可能取出一个四字节常数字 valC。它按顺序方式计算当前指令的下
    一条指令的地址 valP。也就是说，valP 等于 PC 的值加上已取出指令的长度。
    • 译码（decode): 译码阶段从寄存器文件读人最多两个操作数，得到值 valA 和/或 valB。
    通常，它读人指令 rA 和 rB 字段指明的寄存器，不过有些指令是读寄存器%rsp 的。
    • 执行(execute): 在执行阶段，算术/逻辑单元（ALU)要么执行指令指明的操作（根
    据 ifun 的值）， 计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们
    称为 valE。在此，也可能设置条件码。对一条条件传送指令来说，这个阶段会检
    验条件码和传送条件（由 ifun 给出）， 如果条件成立，则更新目标寄存器。同样，
    对一条跳转指令来说，这个阶段会决定是不是应该选择分支。
    •访存(memory): 访存阶段可以将数据写入内存，或者从内存读出数据。读出的值
    为 valM。
    •写回（write back): 写回阶段最多可以写两个结果到寄存器文件。
    •更新 PC(PC update): 将 PC 设置成下一条指令的地址。
#### 4.3.2 SEQ 硬件结构
实现所有 Y86-64 指令所需要的计算可以 写回被组织成 6 个基本阶段：取指、译码、执行、访存、写回和更新 PC。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20212831.png)  

    •白色方框表示时钟寄存器。程序计数器 PC 是 SEQ 中唯一的时钟寄存器。
    •浅蓝色方框表示硬件单元。这包括内存、ALU 等等。在我们所有的处理器实现中，
    都会使用这一组基本的单元。我们把这些单元当作“黑盒子”， 不关心它们的细节
    设计。
    •控制逻辑块用灰色圆角矩形表示。这些块用来从一组信号源中进行选择，或者用来
    计算一些布尔函数。我们会非常详细地分析这些块，包括给出 HCL 描述。
    •线路的名字在白色圆圈中说明。它们只是线路的标识，而不是什么硬件单元。
    •宽度为字 长的数据连接用中等粗度的 线表示。每条这样的线实际上都代表一簇 64
    根线，并列地连在一起，将一个字从硬件的一个部分传送到另一部分。
    •宽度为 字节或更窄的数据连接用细线表示。根据线上要携带的值的类型，每条这样
    的线实际上都代表一簇 4 根或 8 根线。
    •单个位的连接用虚线来表示。这代表芯片上单元与块之间传递的控制值。
#### 4.3.3 SEQ 的时序
SEQ 的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件码寄存
器）， 随机访问存储器(寄存器文件、指令内存和数据内存）。组合逻辑不需要任何时序或
控制棗 只要输入变化了，值就通过逻辑门网络传播。  
四个硬件单元需要对它们的时序进行明确的控制棗 程序计数器、条件码寄
存器、数据内存和寄存器文件。每个时钟周期，程序计数器都会装载新的指令地
址。只有在执行整数运算指令时，才会装载条件码寄存器。只有在执行 rmmovq,pushq
或 Call 指令时，才会写数据内存。寄存器文件的两个写端口允许每个时钟周期更新两个
程序寄存器，不过我们可以用特殊的寄存器 ID 〇XF 作为端口地址，来表明在此端口不应
该执行写操作。  
标号为 1 4 的各个图给出了 4 个状态单元，还有组合逻辑，以及状态单元之间的连
接。组合逻辑被条件码寄存器环绕着，因为有的组合逻辑（例如 ALU)产生输人到条件码
寄存器，而其他部分(例如分支计算和 PC 选择逻辑）又将条件码寄存器作为输人。图中寄
存器文件和数据内存有独立的读连接和写连接，因为读操作沿着这些单元传播，就好像它
们是组合逻辑，而写操作是由时钟控制的。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20213847.png)  
#### 4.3.4 SEQ 阶段的实现
1. 取指阶段  取指阶段包括指令内存硬件单元。以 PC 作为第一个字节（字节 0)的
地址，这个单元一次从内存读出 10 个字
节。第一个字节被解释成指令字节，（标
号为Split的单元）分为两个 4 位的
数。然后，标 号为 icode 和 ifun
的控制逻辑块计算指令和功能码，或者
使之等于从内存读出的值，或者当指令
地址不合法时， 使这些值对应于 nop 指令。
![image]()
2. 译码和写回阶段  实现译码和写回阶段的逻辑的详细情况。把这两个阶段联系在
一起是因为它们都要访问寄存器文件。
寄存器文件有四个端口。它支持同时进行两个读(在端口 A 和 B 上）和两个写（在端口
E 和 M 上）。 每个端口都有一个地址连接和一个数据
连接，地址连接是一个寄存器 ID, 而数据连接是一
组 64 根线路，既可以作为寄存器文件的输出字（对读
端口来说）， 也可以作为它的输人字（对写端口来说）。
两个读端口的地址输入为 srcA 和 srcB, 而两个写端
口的地址输人为 dstE 和 dstM。如果某个地址端口上
的值为特殊标识符 OxF(RNONE), 则表明不需要访问
寄存器。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20214616.png)  
3. 执行阶段  执行阶段包括算术/逻辑单元（ALU)。这个单
元根据 al.ufun 信号的设置，对输入 aluA 和 aluB
执行 ADD SUBTRACT AND 或 EXCLUSIVE0R 运算。
ALU 的输出就是 valS
信号。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20214733.png)  
4. 访存阶段  访存阶段的任务就是读或者写程 序数据。如
图 所示，两个控制块产生内存地址和内存输人
数据（为写操作）的值。另外两个块产生表明应该执
行读操作还是写操作的控制信号。当执行读操作时，
数据内存产生值 valM。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20214933.png)  
5. 更新 PC 阶段  SEQ 中最后一个阶段会产生程序计数器的新值。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-14%20215100.png)  
6. SEQ 小结 通过将执行每条
不同指令所需的步骤组织成一个统一的流程，就可以用很少量的各种硬件单元以及一个时
钟来控制计算的顺序，从而实现整个处理器。不过这样一来，控制逻辑就必须要在这些单
元之间路由信号，并根据指令类型和分支条件产生适当的控制信号。SEQ 唯一的问题就是它太慢了。时钟必须非常慢，以使信号能在一个周期内传播所
有的阶段。这种实现方法不能充分利用硬件单元，因为每个单元只在整个时钟周期的一部分时间
内才被使用。我们会看到引入流水线能获得更好的性能。 
#### 4.4 流水线的通用原理
流水线化的一个重要特性就是提高了系统的吞吐量（throughput), 也就是单位时间内
服务的顾客总数，不过它也会轻微地增加延迟（latency), 也就是服务一个用户所需要的时
间。
#### 4.4.1 计算流水线
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-16%20150810.png)
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-16%20150830.png)
#### 4.4.2 流水线操作的详细说明
指令 I1 经过阶段 C, I2 经 过阶段 B 而 I3 经 过阶段A.
就在时刻 240(点1)时钟上升之前，阶段 A 中计算
的指令 12 的值已经到达第一个流水线寄存器的输人，
但是该寄存器的狀态和输出还保持为指令 II 在阶段 A
中计算的值。指令 II 在阶段 B 中计算的值已经到达第
二个流水线寄存器的输人。当时钟上升时，这些输入被加载到流水线寄存器中，成为寄
存器的输出（点 另外，阶段 A 的输人被设置成发起指令 13 的计算。然后信号传播
通过各个阶段的组合逻辑（点 3)。就像图中点 3 处的曲线化的波阵面（curved wavefront)
表明的那样，信号可能以不同的速率通过各个不同的部分。在时刻 360 之前，结果值到
达流水线寄存器的输入（点 4)。当时刻 360 时钟上升时，各条指令会前进经过一个流水
线阶段。
从这个对流水线操作详细的描述中，我们可以看到减缓时钟不会影响流水线的行为。
信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。另一方
面，如果时钟运行得太快，就会有灾难性的后果。值可能会来不及通过组合逻辑，因此当
时钟上升时，寄存器的输人还不是合法的值。
#### 4.4.3 流水线的局限性
1. 不一致的划分
我们将计算划分为了三个阶段，但是通过这些阶
段的延迟从 50ps 到 150ps 不等。通过所有阶段的延迟和仍然为 300ps。不过，运行时钟的
速率是由最慢的阶段的延迟限制的。流水线图表明，每个时钟周期，阶段 A 都会空闲（用
白色方框表示）l〇〇ps， 而阶段 C 会空闲 50ps。只有阶段 B 会一直处于活动状态。我们必
须将时钟周期设为 150+20=170ps。得到吞吐量为 5.88GIPS。另外，由于时钟周期减慢了，延迟也增加到了 510ps。
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-16%20152807.png)  
2. 流水线过深，收益反而下降
在这个例子中，我们把计算分成了 6 个
阶段，每个阶段需要 50ps。 在每对阶段之间插人流水线寄存器就得到了一个六阶段流水
线。这个系统的最小时钟周期为 50+20=70ps, 吞吐量为 14.29GIPS。因此，通过将流
水线的阶段数加倍，我们将性能提高了14.29/8.33=1.71。虽然我们将每个计算时钟的时
间缩短了两倍，但是由于通过流水线寄存器的延迟，吞吐量并没有加倍。这个延迟成了流
水线吞 吐量的一个制约因素。在我 们的新设计中，这个延迟占到了整个时钟周期
的 28.6%。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-16%20153322.png)  
#### 4.4.4 带反馈的流水线系统
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-16%20153855.png)  
#### 4.5 Y86-64 的流水线实现
设计一个流水线化的 Y86-64 处理器。   
首先，对顺序的 SEQ 处理器做一点小的改动，将 PC 的计算挪到取指阶段。  
然后，在各个阶段之间加上流水线寄存器。  
#### 4.5.1 SEQ+: 重新安排计算阶段
作为实现流水线化设计的一个过渡步骤，我们必须稍微调整一下 SEQ 中五个阶段的顺序，使得更新 PC 阶段在一个时钟周期开始时执行，而不是结束时才执行。
我们移动 PC 阶段，使得它的逻辑在时钟周期开始时活动，使它计算当前指令的 PC值。
在 SEQ 中 PC 计算发生在时钟周期结束的时候，根据当前时钟周期内计算出的信号值来计算 PC 寄存器的
新值。在 SEQ+中我们创建状态寄存器来保存在一条指令执行过程中计算出
来的信号。然后，当一个新的时钟周期开始时，这些信号值通过同样的逻辑来计算当前指
令的 PC。我们将这些寄存器标号为 pIcode 、 pCnd等等，来指明在任一给定的周期，
它们保存的是前一个周期中产生的控制信号。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-20%20203407.png)  
#### 4.5.2 插入流水线寄存器
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-20%20203843.png)  
流水线寄存器按如下方式标号：  
F 保存程序计数器的预测值，稍后讨论。  
D 位于取指和译码阶段之间。它保存关于最新取出的指令的信息，即将由译码阶段进行处理。  
E 位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值的信息，即将由执行阶段进行处理。  
M 位于执行和访存阶段之间。它保存最新执行的指令的结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。  
W 位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成 ret 指令时，它还要向 PC 选择逻辑提供返回地址。  
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-20%20204710.png)  
以下代码序列如何通过我们的五阶段流水线，其中注释将各条指令标识为 I1~I5 以便引用：  
```
irmovq $1,%rax # I1
irmovq $2,%rbx # I2
irmovq $3,%rcx # I3
irmovq $4,%rdx # I4
halt           # I5
```
![image](https://github.com/sunhaofeng2001/-/blob/master/IMG/%E6%89%B9%E6%B3%A8%202020-08-20%20205159.png)  
上面一条数字表明各个阶段发生的时钟周期。例如，在周期 1 取出指令 II, 然后它开
始通过流水线各个阶段，到周期 5 结束后，其结果写人寄存器文件。在周期 2 取出指令
12, 到周期 6 结束后，其结果写回，以此类推。在最下面, 我们给出了当周期为 5 时的流
水线的扩展图。此时，每个流水线阶段中各有一条指令。
指令是自底向上的流
动的。周期 5 时的扩展图表明的流水线阶段，取指阶段在底部，写回阶段在最上面，同流
水线硬件图（图 4-41)表明的一样。如果看看流水线各个阶段中指令的顺序，就会发现它们
出现的顺序与在程序中列出的顺序一样。因为正常的程序是从上到下列出的，我们保留这
种顺序，让流水线从下到上进行。
#### 4.5.3 对信号进行重新排列和标号
顺序实现 SEQ 和 SEQ+在一个时刻只处理一条指令，因此诸如 valC , srcA 和 valE
这样的信号值有唯一的值。
#### 4.5.4 预测下一个 PC
流水线化设计的目的就
是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进人执行阶段并
最终完成。要是达到这个目的也就意味着吞吐量是每个时钟周期一条指令。要做到这一点，
我们必须在取出当前指令之后，马上确定下一条指令的位置。不幸的是，如果取出的指令是
条件分支指令，要到几个周期后，也就是指令通过执行阶段之后，我们才能知道是否要选择
分支。类似地，如果取出的指令是 ret, 要到指令通过访存阶段，才能确定返回地址。
除了条件转移指令和 ret 以外，根据取指阶段中计算出的信息，我们能够确定下一条
指令的地址。对于 call 和 jmp(无条件转移）来说，下一条指令的地址是指令中的常数字
valG, 而对于其他指令来说就是 valP 。因此，通过预测 PC 的下一个值，在大多数情况
下，我们能达到每个时钟周期发射一条新指令的目的。对大多数指令类型来说，我们的预
测是完全可靠的。对条件转移来说，我们既可以预测选择了分支，那么新 PC 值应为
valC。也可以预测没有选择分支，那么新 PC 值应为 valP。无论哪种情况，我们都必须
以某种方式来处理预测错误的情况，因为此时已经取出并部分执行了错误的指令。
猜测分支方向并根据猜测开始取指的技术称为分支预测。实际上所有的处理器都采用
了某种形式的此类技术。
#### 4.5.5 流水线冒险

#### 4.6 小结
指令集体系结构，即ISA, 在处理器行为（就指令集合及其编码而言）和如何实现处
理器之间提供了一层抽象。ISA 提供了程序执行的一种顺序说明，也就是一条指令执行完了，下一条指
令才会开始。
从]LAJ2 指令开始，大大简化数据类型、地址模式和指令编码，我们定义了 Y86-64 指令集。得到的
ISA 既有 RISC 指令集的属性，也有 CISC 指令集的属性。然后，将不同指令组织放到五个阶段中处理,
在此，根据被执行的指令的不同，每个阶段中的操作也不相同。据此，我们构造了 SEQ 处理器，其中每
个时钟周期执行一条指令，它会通过所有五个阶段。
流水线化通过让不同的阶段并行操作，改进了系统的吞吐量性能。在任意一个给定的时刻，多条指
令被不同的阶段处理。在引人这种并行性的过程中，我们必须非常小心，以提供与程序的顺序执行相同
的程序级行为。通过重新调整 SEQ 各个部分的顺序，引人流水线，我们得到 SEQ+,接着添加流水线寄
存器，创建出 PIPE-流水线。然后，添加了转发逻辑，加速了将结果从一条指令发送到另一条指令，从
而提高了流水线的性能。有几种特殊情况需要额外的流水线控制逻辑来暂停或取消一些流水线阶段。
管理复杂性是首要问题。 我们不需要直接实现ISA。 
